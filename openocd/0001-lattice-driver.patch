From be966a02561b19792d5cad5ba66ba1bbd39e42c1 Mon Sep 17 00:00:00 2001
From: xli-lscc <xueping.li@latticesemi.com>
Date: Wed, 21 Apr 2021 16:20:47 +0800
Subject: [PATCH] lattice propel 2.0 driver

---
 configure.ac                                       | 1662 +++++++--------
 src/jtag/drivers/Makefile.am                       |  374 ++--
 src/jtag/drivers/jtag_tcp.c                        |   10 +-
 .../lattice_usb_cableserver/LatticeClient.h        |  293 +++
 .../lattice_usb_cableserver/LatticeClientUtil.h    |   58 +
 .../drivers/lattice_usb_cableserver/Makefile.am    |   11 +
 src/jtag/drivers/lattice_usb_cableserver/a.h       |    0
 .../lattice_usb_cableserver/cableserver_client.dll |  Bin 0 -> 79360 bytes
 .../lattice_usb_cableserver/cableserver_client.lib |  Bin 0 -> 12944 bytes
 .../lattice_usb_cableserver/cableserverclient.xml  |  138 ++
 .../lattice_usb_cableserverclient.c                | 2122 ++++++++++++++++++++
 .../lscc_cableserver_client.h                      |   61 +
 src/jtag/interfaces.c                              |  516 ++---
 src/target/vexriscv.c                              |   16 +-
 tcl/interface/ftdi/digilent-hs2.cfg                |   46 +-
 tcl/interface/lattice-usb-cableserver.cfg          |   12 +
 tcl/target/vexriscv_sim.cfg                        |   63 +-
 17 files changed, 4065 insertions(+), 1317 deletions(-)
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/LatticeClient.h
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/LatticeClientUtil.h
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/Makefile.am
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/a.h
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/cableserver_client.dll
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/cableserver_client.lib
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/cableserverclient.xml
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/lscc_cableserver_client.h
 create mode 100644 tcl/interface/lattice-usb-cableserver.cfg

diff --git a/configure.ac b/configure.ac
index d4338df..8349441 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,830 +1,832 @@
-AC_PREREQ(2.64)
-AC_INIT([openocd], [0.10.0+dev],
-  [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
-AC_CONFIG_SRCDIR([src/openocd.c])
-
-m4_include([config_subdir.m4])dnl
-
-# check for makeinfo before calling AM_INIT_AUTOMAKE
-AC_CHECK_PROG([MAKEINFO], [makeinfo], [makeinfo])
-AS_IF([test "x$MAKEINFO" = "x"], [
-  MAKEINFO='echo makeinfo missing; true'
-  AC_MSG_WARN([Info documentation will not be built.])
-])
-AC_SUBST([MAKEINFO])
-
-AM_INIT_AUTOMAKE([-Wall -Wno-portability dist-bzip2 dist-zip subdir-objects])
-
-AC_CONFIG_HEADERS([config.h])
-AH_BOTTOM([
-#include <helper/system.h>
-#include <helper/types.h>
-#include <helper/replacements.h>
-])
-
-AC_LANG_C
-AC_PROG_CC
-AC_PROG_CC_C99
-AM_PROG_CC_C_O
-AC_PROG_RANLIB
-PKG_PROG_PKG_CONFIG([0.23])
-
-dnl disable checks for C++, Fortran and GNU Java Compiler
-m4_defun([_LT_AC_LANG_CXX_CONFIG], [:])
-m4_defun([_LT_AC_LANG_F77_CONFIG], [:])
-m4_defun([_LT_AC_LANG_GCJ_CONFIG], [:])
-AC_DISABLE_SHARED
-AC_PROG_LIBTOOL
-AC_SUBST([LIBTOOL_DEPS])
-
-dnl configure checks required for Jim files (these are obsolete w/ C99)
-AC_C_CONST
-AC_TYPE_LONG_LONG_INT
-
-AC_SEARCH_LIBS([ioperm], [ioperm])
-AC_SEARCH_LIBS([dlopen], [dl])
-
-AC_CHECK_HEADERS([sys/socket.h])
-AC_CHECK_HEADERS([elf.h])
-AC_CHECK_HEADERS([dirent.h])
-AC_CHECK_HEADERS([fcntl.h])
-AC_CHECK_HEADERS([malloc.h])
-AC_CHECK_HEADERS([netdb.h])
-AC_CHECK_HEADERS([poll.h])
-AC_CHECK_HEADERS([pthread.h])
-AC_CHECK_HEADERS([strings.h])
-AC_CHECK_HEADERS([sys/ioctl.h])
-AC_CHECK_HEADERS([sys/param.h])
-AC_CHECK_HEADERS([sys/select.h])
-AC_CHECK_HEADERS([sys/stat.h])
-AC_CHECK_HEADERS([sys/sysctl.h])
-AC_CHECK_HEADERS([sys/time.h])
-AC_CHECK_HEADERS([sys/types.h])
-AC_CHECK_HEADERS([unistd.h])
-AC_CHECK_HEADERS([arpa/inet.h ifaddrs.h netinet/in.h netinet/tcp.h net/if.h], [], [], [dnl
-#include <stdio.h>
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-])
-
-AC_HEADER_ASSERT
-AC_HEADER_STDBOOL
-AC_HEADER_TIME
-
-AC_C_BIGENDIAN
-
-AC_CHECK_FUNCS([strndup])
-AC_CHECK_FUNCS([strnlen])
-AC_CHECK_FUNCS([gettimeofday])
-AC_CHECK_FUNCS([usleep])
-AC_CHECK_FUNCS([vasprintf])
-AC_CHECK_FUNCS([realpath])
-
-# guess-rev.sh only exists in the repository, not in the released archives
-AC_MSG_CHECKING([whether to build a release])
-AS_IF([test -x "$srcdir/guess-rev.sh"], [
-  build_release=no
-], [
-  build_release=yes
-])
-AC_MSG_RESULT([$build_release])
-
-# Adapter drivers
-# 1st column -- configure option
-# 2nd column -- description
-# 3rd column -- symbol used for both config.h and automake
-m4_define([ADAPTER_ARG], [m4_argn([1], $1)])
-m4_define([ADAPTER_DESC], [m4_argn([2], $1)])
-m4_define([ADAPTER_SYM], [m4_argn([3], $1)])
-m4_define([ADAPTER_VAR], [enable_[]ADAPTER_ARG($1)])
-m4_define([ADAPTER_OPT], [m4_translit(ADAPTER_ARG($1), [_], [-])])
-
-m4_define([USB1_ADAPTERS],
-	[[[ftdi], [MPSSE mode of FTDI based devices], [FTDI]],
-	[[stlink], [ST-Link JTAG Programmer], [HLADAPTER_STLINK]],
-	[[ti_icdi], [TI ICDI JTAG Programmer], [HLADAPTER_ICDI]],
-	[[ulink], [Keil ULINK JTAG Programmer], [ULINK]],
-	[[usb_blaster_2], [Altera USB-Blaster II Compatible], [USB_BLASTER_2]],
-	[[ft232r], [Bitbang mode of FT232R based devices], [FT232R]],
-	[[vsllink], [Versaloon-Link JTAG Programmer], [VSLLINK]],
-	[[xds110], [TI XDS110 Debug Probe], [XDS110]]])
-
-m4_define([USB_ADAPTERS],
-	[[[osbdm], [OSBDM (JTAG only) Programmer], [OSBDM]],
-	[[opendous], [eStick/opendous JTAG Programmer], [OPENDOUS]],
-	[[aice], [Andes JTAG Programmer], [AICE]]])
-
-m4_define([USB0_ADAPTERS],
-	[[[usbprog], [USBProg JTAG Programmer], [USBPROG]],
-	[[rlink], [Raisonance RLink JTAG Programmer], [RLINK]],
-	[[armjtagew], [Olimex ARM-JTAG-EW Programmer], [ARMJTAGEW]]])
-
-m4_define([HIDAPI_ADAPTERS],
-	[[[cmsis_dap], [CMSIS-DAP Compliant Debugger], [CMSIS_DAP]]])
-
-m4_define([HIDAPI_USB1_ADAPTERS],
-	[[[kitprog], [Cypress KitProg Programmer], [KITPROG]]])
-
-m4_define([LIBFTDI_ADAPTERS],
-	[[[usb_blaster], [Altera USB-Blaster Compatible], [USB_BLASTER]],
-	[[presto], [ASIX Presto Adapter], [PRESTO]],
-	[[openjtag], [OpenJTAG Adapter], [OPENJTAG]]])
-
-m4_define([LIBJAYLINK_ADAPTERS],
-	[[[jlink], [SEGGER J-Link Programmer], [JLINK]]])
-
-
-AC_ARG_ENABLE([doxygen-html],
-  AS_HELP_STRING([--disable-doxygen-html],
-    [Disable building Doxygen manual as HTML.]),
-  [doxygen_as_html=$enableval], [doxygen_as_html=yes])
-AC_SUBST([doxygen_as_html])
-AC_MSG_CHECKING([whether to build Doxygen as HTML])
-AC_MSG_RESULT([$doxygen_as_html])
-
-AC_ARG_ENABLE([doxygen-pdf],
-  AS_HELP_STRING([--enable-doxygen-pdf],
-    [Enable building Doxygen manual as PDF.]),
-  [doxygen_as_pdf=$enableval], [doxygen_as_pdf=no])
-AC_SUBST([doxygen_as_pdf])
-AC_MSG_CHECKING([whether to build Doxygen as PDF])
-AC_MSG_RESULT([$doxygen_as_pdf])
-
-AC_ARG_ENABLE([gccwarnings],
-  AS_HELP_STRING([--disable-gccwarnings], [Disable compiler warnings]),
-  [gcc_warnings=$enableval], [gcc_warnings=yes])
-
-AC_ARG_ENABLE([wextra],
-  AS_HELP_STRING([--disable-wextra], [Disable extra compiler warnings]),
-  [gcc_wextra=$enableval], [gcc_wextra=$gcc_warnings])
-
-AC_ARG_ENABLE([werror],
-  AS_HELP_STRING([--disable-werror], [Do not treat warnings as errors]),
-  [gcc_werror=$enableval], [gcc_werror=$gcc_warnings])
-
-# set default verbose options, overridden by following options
-debug_jtag_io=no
-debug_usb_io=no
-debug_usb_comms=no
-
-AC_ARG_ENABLE([verbose],
-  AS_HELP_STRING([--enable-verbose],
-      [Enable verbose JTAG I/O messages (for debugging).]),
-  [
-  debug_jtag_io=$enableval
-  debug_usb_io=$enableval
-  debug_usb_comms=$enableval
-  ], [])
-
-AC_ARG_ENABLE([verbose_jtag_io],
-  AS_HELP_STRING([--enable-verbose-jtag-io],
-      [Enable verbose JTAG I/O messages (for debugging).]),
-  [debug_jtag_io=$enableval], [])
-
-AC_ARG_ENABLE([verbose_usb_io],
-  AS_HELP_STRING([--enable-verbose-usb-io],
-      [Enable verbose USB I/O messages (for debugging)]),
-  [debug_usb_io=$enableval], [])
-
-AC_ARG_ENABLE([verbose_usb_comms],
-  AS_HELP_STRING([--enable-verbose-usb-comms],
-      [Enable verbose USB communication messages (for debugging)]),
-  [debug_usb_comms=$enableval], [])
-
-AC_MSG_CHECKING([whether to enable verbose JTAG I/O messages]);
-AC_MSG_RESULT([$debug_jtag_io])
-AS_IF([test "x$debug_jtag_io" = "xyes"], [
-  AC_DEFINE([_DEBUG_JTAG_IO_],[1], [Print verbose JTAG I/O messages])
-])
-
-AC_MSG_CHECKING([whether to enable verbose USB I/O messages]);
-AC_MSG_RESULT([$debug_usb_io])
-AS_IF([test "x$debug_usb_io" = "xyes"], [
-  AC_DEFINE([_DEBUG_USB_IO_],[1], [Print verbose USB I/O messages])
-])
-
-AC_MSG_CHECKING([whether to enable verbose USB communication messages]);
-AC_MSG_RESULT([$debug_usb_comms])
-AS_IF([test "x$debug_usb_comms" = "xyes"], [
-  AC_DEFINE([_DEBUG_USB_COMMS_],[1], [Print verbose USB communication messages])
-])
-
-debug_malloc=no
-AC_ARG_ENABLE([malloc_logging],
-  AS_HELP_STRING([--enable-malloc-logging],
-      [Include free space in logging messages (requires malloc.h).]),
-  [debug_malloc=$enableval], [])
-
-AC_MSG_CHECKING([whether to enable malloc free space logging]);
-AC_MSG_RESULT([$debug_malloc])
-AS_IF([test "x$debug_malloc" = "xyes"], [
-  AC_DEFINE([_DEBUG_FREE_SPACE_],[1], [Include malloc free space in logging])
-])
-
-AC_ARG_ENABLE([dummy],
-  AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]),
-  [build_dummy=$enableval], [build_dummy=no])
-
-m4_define([AC_ARG_ADAPTERS], [
-  m4_foreach([adapter], [$1],
-	[AC_ARG_ENABLE(ADAPTER_OPT([adapter]),
-		AS_HELP_STRING([--enable-ADAPTER_OPT([adapter])],
-			[Enable building support for the ]ADAPTER_DESC([adapter])[ (default is $2)]),
-		[], [ADAPTER_VAR([adapter])=$2])
-  ])
-])
-
-AC_ARG_ADAPTERS([
-  USB1_ADAPTERS,
-  USB_ADAPTERS,
-  USB0_ADAPTERS,
-  HIDAPI_ADAPTERS,
-  HIDAPI_USB1_ADAPTERS,
-  LIBFTDI_ADAPTERS,
-  LIBJAYLINK_ADAPTERS
-  ],[auto])
-
-AC_ARG_ENABLE([parport],
-  AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
-  [build_parport=$enableval], [build_parport=no])
-
-AC_ARG_ENABLE([parport_ppdev],
-  AS_HELP_STRING([--disable-parport-ppdev],
-      [Disable use of ppdev (/dev/parportN) for parport (for x86 only)]),
-    [parport_use_ppdev=$enableval], [parport_use_ppdev=yes])
-
-AC_ARG_ENABLE([parport_giveio],
-    AS_HELP_STRING([--enable-parport-giveio],
-      [Enable use of giveio for parport (for CygWin only)]),
-    [parport_use_giveio=$enableval], [parport_use_giveio=])
-
-AC_ARG_ENABLE([jtag_vpi],
-  AS_HELP_STRING([--enable-jtag_vpi], [Enable building support for JTAG VPI]),
-  [build_jtag_vpi=$enableval], [build_jtag_vpi=no])
-
-AC_ARG_ENABLE([amtjtagaccel],
-  AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
-  [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
-
-AC_ARG_ENABLE([zy1000_master],
-  AS_HELP_STRING([--enable-zy1000-master], [Use ZY1000 JTAG master registers]),
-  [build_zy1000_master=$enableval], [build_zy1000_master=no])
-
-AC_ARG_ENABLE([zy1000],
-  AS_HELP_STRING([--enable-zy1000], [Enable ZY1000 interface]),
-  [build_zy1000=$enableval], [build_zy1000=no])
-
-AC_ARG_ENABLE([ioutil],
-  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]),
-  [build_ioutil=$enableval], [build_ioutil=no])
-
-AS_CASE(["${host_cpu}"],
-  [arm*], [
-    AC_ARG_ENABLE([ep93xx],
-      AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]),
-      [build_ep93xx=$enableval], [build_ep93xx=no])
-
-    AC_ARG_ENABLE([at91rm9200],
-      AS_HELP_STRING([--enable-at91rm9200], [Enable building support for AT91RM9200 based SBCs]),
-      [build_at91rm9200=$enableval], [build_at91rm9200=no])
-
-    AC_ARG_ENABLE([bcm2835gpio],
-      AS_HELP_STRING([--enable-bcm2835gpio], [Enable building support for bitbanging on BCM2835 (as found in Raspberry Pi)]),
-      [build_bcm2835gpio=$enableval], [build_bcm2835gpio=no])
-    AC_ARG_ENABLE([imx_gpio],
-      AS_HELP_STRING([--enable-imx_gpio], [Enable building support for bitbanging on NXP IMX processors]),
-      [build_imx_gpio=$enableval], [build_imx_gpio=no])
-  ],
-  [
-    build_ep93xx=no
-    build_at91rm9200=no
-    build_bcm2835gpio=no
-    build_imx_gpio=no
-])
-
-AC_ARG_ENABLE([gw16012],
-  AS_HELP_STRING([--enable-gw16012], [Enable building support for the Gateworks GW16012 JTAG Programmer]),
-  [build_gw16012=$enableval], [build_gw16012=no])
-
-AC_ARG_ENABLE([oocd_trace],
-  AS_HELP_STRING([--enable-oocd_trace],
-  [Enable building support for some prototype OpenOCD+trace ETM capture hardware]),
-  [build_oocd_trace=$enableval], [build_oocd_trace=no])
-
-AC_ARG_ENABLE([buspirate],
-  AS_HELP_STRING([--enable-buspirate], [Enable building support for the Buspirate]),
-  [build_buspirate=$enableval], [build_buspirate=no])
-
-AC_ARG_ENABLE([sysfsgpio],
-  AS_HELP_STRING([--enable-sysfsgpio], [Enable building support for programming driven via sysfs gpios.]),
-  [build_sysfsgpio=$enableval], [build_sysfsgpio=no])
-
-AS_CASE([$host_os],
-  [linux*], [],
-  [
-    AS_IF([test "x$build_sysfsgpio" = "xyes"], [
-      AC_MSG_ERROR([sysfsgpio is only available on linux])
-    ])
-])
-
-AC_ARG_ENABLE([minidriver_dummy],
-  AS_HELP_STRING([--enable-minidriver-dummy], [Enable the dummy minidriver.]),
-  [build_minidriver_dummy=$enableval], [build_minidriver_dummy=no])
-
-AC_ARG_ENABLE([internal-jimtcl],
-  AS_HELP_STRING([--disable-internal-jimtcl], [Disable building internal jimtcl]),
-  [use_internal_jimtcl=$enableval], [use_internal_jimtcl=yes])
-
-AC_ARG_ENABLE([internal-libjaylink],
-  AS_HELP_STRING([--disable-internal-libjaylink],
-  [Disable building internal libjaylink]),
-  [use_internal_libjaylink=$enableval], [use_internal_libjaylink=yes])
-
-AC_ARG_ENABLE([target64],
-  AS_HELP_STRING([--disable-target64], [Disable 64-bit target address]),
-    [build_target64=$enableval], [build_target64=yes])
-
-build_minidriver=no
-AC_MSG_CHECKING([whether to enable ZY1000 minidriver])
-AS_IF([test "x$build_zy1000" = "xyes"], [
-  AS_IF([test "x$build_minidriver" = "xyes"], [
-    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
-  ])
-  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
-      [Define to 1 if you have the <jtag_minidriver.h> header file.])
-  build_minidriver=yes
-])
-AC_MSG_RESULT([$build_zy1000])
-
-AC_ARG_ENABLE([remote-bitbang],
-  AS_HELP_STRING([--enable-remote-bitbang], [Enable building support for the Remote Bitbang jtag driver]),
-  [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
-
-AC_MSG_CHECKING([whether to enable dummy minidriver])
-AS_IF([test "x$build_minidriver_dummy" = "xyes"], [
-  AS_IF([test "x$build_minidriver" = "xyes"], [
-    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
-  ])
-  build_minidriver=yes
-  AC_DEFINE([BUILD_MINIDRIVER_DUMMY], [1], [Use the dummy minidriver.])
-  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
-      [Define to 1 if you have the <jtag_minidriver.h> header file.])
-])
-AC_MSG_RESULT([$build_minidriver_dummy])
-
-AC_MSG_CHECKING([whether standard drivers can be built])
-AS_IF([test "x$build_minidriver" = "xyes"], [
-  AC_MSG_RESULT([no])
-  AC_MSG_WARN([Using the minidriver disables all other drivers.])
-  sleep 2
-], [
-  AC_MSG_RESULT([yes])
-])
-
-AS_CASE(["${host_cpu}"],
-  [i?86|x86*], [],
-  [
-    AS_IF([test "x$parport_use_ppdev" = "xno"], [
-      AC_MSG_WARN([--disable-parport-ppdev is not supported by the host CPU])
-    ])
-    parport_use_ppdev=yes
-])
-
-AS_CASE([$host],
-  [*-cygwin*], [
-    is_win32=yes
-    parport_use_ppdev=no
-
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[return __MINGW32__;]])],
-      [is_mingw=yes],[is_mingw=no])
-    AS_IF([test "x$is_mingw" = "xyes"], [
-      AS_IF([test "x$parport_use_giveio" = "xno"], [
-        AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
-      ])
-      parport_use_giveio=yes
-      is_cygwin=no
-    ], [
-      is_cygwin=yes
-      # sys/io.h needed under cygwin for parport access
-      AS_IF([test "x$build_parport" = "xyes"], [
-        AC_CHECK_HEADERS([sys/io.h],[],AC_MSG_ERROR([Please install the cygwin ioperm package]))
-      ])
-    ])
-  ],
-  [*-mingw* | *-msys*], [
-    is_mingw=yes
-    is_win32=yes
-    parport_use_ppdev=no
-
-    AS_IF([test "x$parport_use_giveio" = "xno"], [
-      AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
-    ])
-    parport_use_giveio=yes
-
-    AS_IF([test "x$build_buspirate" = "xyes"], [
-      AC_MSG_ERROR([buspirate currently not supported by MinGW32 hosts])
-    ])
-
-    AC_SUBST([HOST_CPPFLAGS], [-D__USE_MINGW_ANSI_STDIO])
-  ],
-  [*darwin*], [
-    is_darwin=yes
-
-    AS_IF([test "x$parport_use_giveio" = "xyes"], [
-      AC_MSG_WARN([--enable-parport-giveio cannot be used by Darwin hosts])
-    ])
-    parport_use_giveio=no
-  ],
-  [
-    AS_IF([test "x$parport_use_giveio" = "xyes"], [
-      AC_MSG_WARN([--enable-parport-giveio cannot be used by ]$host[ hosts])
-    ])
-    parport_use_giveio=no
-])
-
-AS_IF([test "x$is_cygwin" = "xyes"], [
-    AC_DEFINE([IS_CYGWIN], [1], [1 if building for Cygwin.])
-], [
-    AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
-])
-
-AS_IF([test "x$is_mingw" = "xyes"], [
-    AC_DEFINE([IS_MINGW], [1], [1 if building for Mingw.])
-], [
-    AC_DEFINE([IS_MINGW], [0], [0 if not building for Mingw.])
-])
-
-AS_IF([test "x$is_win32" = "xyes"], [
-    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
-], [
-    AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
-])
-
-AS_IF([test "x$is_darwin" = "xyes"], [
-    AC_DEFINE([IS_DARWIN], [1], [1 if building for Darwin.])
-], [
-    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
-])
-
-AS_IF([test "x$build_parport" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_PARPORT], [1], [1 if you want parport.])
-], [
-  AC_DEFINE([BUILD_PARPORT], [0], [0 if you don't want parport.])
-])
-
-AS_IF([test "x$build_dummy" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_DUMMY], [1], [1 if you want dummy driver.])
-], [
-  AC_DEFINE([BUILD_DUMMY], [0], [0 if you don't want dummy driver.])
-])
-
-AS_IF([test "x$build_ep93xx" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_EP93XX], [1], [1 if you want ep93xx.])
-], [
-  AC_DEFINE([BUILD_EP93XX], [0], [0 if you don't want ep93xx.])
-])
-
-AS_IF([test "x$build_zy1000" = "xyes"], [
-  AC_DEFINE([BUILD_ZY1000], [1], [1 if you want ZY1000.])
-], [
-  AC_DEFINE([BUILD_ZY1000], [0], [0 if you don't want ZY1000.])
-])
-
-AS_IF([test "x$build_zy1000_master" = "xyes"], [
-  AC_DEFINE([BUILD_ZY1000_MASTER], [1], [1 if you want ZY1000 JTAG master registers.])
-], [
-  AC_DEFINE([BUILD_ZY1000_MASTER], [0], [0 if you don't want ZY1000 JTAG master registers.])
-])
-
-AS_IF([test "x$build_at91rm9200" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_AT91RM9200], [1], [1 if you want at91rm9200.])
-], [
-  AC_DEFINE([BUILD_AT91RM9200], [0], [0 if you don't want at91rm9200.])
-])
-
-AS_IF([test "x$build_bcm2835gpio" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_BCM2835GPIO], [1], [1 if you want bcm2835gpio.])
-], [
-  AC_DEFINE([BUILD_BCM2835GPIO], [0], [0 if you don't want bcm2835gpio.])
-])
-
-AS_IF([test "x$build_imx_gpio" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_IMX_GPIO], [1], [1 if you want imx_gpio.])
-], [
-  AC_DEFINE([BUILD_IMX_GPIO], [0], [0 if you don't want imx_gpio.])
-])
-
-AS_IF([test "x$parport_use_ppdev" = "xyes"], [
-  AC_DEFINE([PARPORT_USE_PPDEV], [1], [1 if you want parport to use ppdev.])
-], [
-  AC_DEFINE([PARPORT_USE_PPDEV], [0], [0 if you don't want parport to use ppdev.])
-])
-
-AS_IF([test "x$parport_use_giveio" = "xyes"], [
-  AC_DEFINE([PARPORT_USE_GIVEIO], [1], [1 if you want parport to use giveio.])
-], [
-  AC_DEFINE([PARPORT_USE_GIVEIO], [0], [0 if you don't want parport to use giveio.])
-])
-
-AS_IF([test "x$build_jtag_vpi" = "xyes"], [
-  AC_DEFINE([BUILD_JTAG_VPI], [1], [1 if you want JTAG VPI.])
-], [
-  AC_DEFINE([BUILD_JTAG_VPI], [0], [0 if you don't want JTAG VPI.])
-])
-
-AS_IF([test "x$build_amtjtagaccel" = "xyes"], [
-  AC_DEFINE([BUILD_AMTJTAGACCEL], [1], [1 if you want the Amontec JTAG-Accelerator driver.])
-], [
-  AC_DEFINE([BUILD_AMTJTAGACCEL], [0], [0 if you don't want the Amontec JTAG-Accelerator driver.])
-])
-
-AS_IF([test "x$build_gw16012" = "xyes"], [
-  AC_DEFINE([BUILD_GW16012], [1], [1 if you want the Gateworks GW16012 driver.])
-], [
-  AC_DEFINE([BUILD_GW16012], [0], [0 if you don't want the Gateworks GW16012 driver.])
-])
-
-AS_IF([test "x$build_oocd_trace" = "xyes"], [
-  AC_DEFINE([BUILD_OOCD_TRACE], [1], [1 if you want the OpenOCD+trace ETM capture driver.])
-], [
-  AC_DEFINE([BUILD_OOCD_TRACE], [0], [0 if you don't want the OpenOCD+trace ETM capture driver.])
-])
-
-AS_IF([test "x$build_buspirate" = "xyes"], [
-  AC_DEFINE([BUILD_BUSPIRATE], [1], [1 if you want the Buspirate JTAG driver.])
-], [
-  AC_DEFINE([BUILD_BUSPIRATE], [0], [0 if you don't want the Buspirate JTAG driver.])
-])
-
-AS_IF([test "x$use_internal_jimtcl" = "xyes"], [
-  AS_IF([test -f "$srcdir/jimtcl/configure.ac"], [
-    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
-  ], [
-    AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
-  ])
-])
-
-AS_IF([test "x$build_remote_bitbang" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_REMOTE_BITBANG], [1], [1 if you want the Remote Bitbang JTAG driver.])
-], [
-  AC_DEFINE([BUILD_REMOTE_BITBANG], [0], [0 if you don't want the Remote Bitbang JTAG driver.])
-])
-
-AS_IF([test "x$build_sysfsgpio" = "xyes"], [
-  build_bitbang=yes
-  AC_DEFINE([BUILD_SYSFSGPIO], [1], [1 if you want the SysfsGPIO driver.])
-], [
-  AC_DEFINE([BUILD_SYSFSGPIO], [0], [0 if you don't want SysfsGPIO driver.])
-])
-
-AS_IF([test "x$build_target64" = "xyes"], [
-  AC_DEFINE([BUILD_TARGET64], [1], [1 if you want 64-bit addresses.])
-], [
-  AC_DEFINE([BUILD_TARGET64], [0], [0 if you don't want 64-bit addresses.])
-])
-
-
-PKG_CHECK_MODULES([LIBUSB1], [libusb-1.0], [
-	use_libusb1=yes
-	AC_DEFINE([HAVE_LIBUSB1], [1], [Define if you have libusb-1.x])
-	PKG_CHECK_EXISTS([libusb-1.0 >= 1.0.9],
-		[AC_DEFINE([HAVE_LIBUSB_ERROR_NAME], [1], [Define if your libusb has libusb_error_name()])],
-		[AC_MSG_WARN([libusb-1.x older than 1.0.9 detected, consider updating])])
-	LIBUSB1_CFLAGS=`echo $LIBUSB1_CFLAGS | sed 's/-I/-isystem /'`
-	AC_MSG_NOTICE([libusb-1.0 header bug workaround: LIBUSB1_CFLAGS changed to "$LIBUSB1_CFLAGS"])
-	PKG_CHECK_EXISTS([libusb-1.0 >= 1.0.16],
-		[AC_DEFINE([HAVE_LIBUSB_GET_PORT_NUMBERS], [1], [Define if your libusb has libusb_get_port_numbers()])])
-  ], [
-	use_libusb1=no
-	AC_MSG_WARN([libusb-1.x not found, trying legacy libusb-0.1 as a fallback; consider installing libusb-1.x instead])
-])
-
-PKG_CHECK_MODULES([LIBUSB0], [libusb], [use_libusb0=yes], [use_libusb0=no])
-
-for hidapi_lib in hidapi hidapi-hidraw hidapi-libusb; do
-	PKG_CHECK_MODULES([HIDAPI],[$hidapi_lib],[
-		use_hidapi=yes
-		break
-	],[
-		use_hidapi=no
-	])
-done
-
-PKG_CHECK_MODULES([LIBFTDI], [libftdi1], [use_libftdi=yes], [
-	PKG_CHECK_MODULES([LIBFTDI], [libftdi], [use_libftdi=yes], [use_libftdi=no])
-])
-
-PKG_CHECK_MODULES([LIBJAYLINK], [libjaylink >= 0.2],
-	[use_libjaylink=yes], [use_libjaylink=no])
-
-m4_define([PROCESS_ADAPTERS], [
-  m4_foreach([adapter], [$1], [
-	AS_IF([test "x$build_zy1000" = "xyes"], [
-		ADAPTER_VAR([adapter])=no
-	])
-	AS_IF([test $2], [
-		AS_IF([test "x$ADAPTER_VAR([adapter])" != "xno"], [
-			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [1], [1 if you want the ]ADAPTER_DESC([adapter]).)
-		], [
-			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [0], [0 if you do not want the ]ADAPTER_DESC([adapter]).)
-		])
-	], [
-		AS_IF([test "x$ADAPTER_VAR([adapter])" = "xyes"], [
-			AC_MSG_ERROR([$3 is required for the ADAPTER_DESC([adapter])])
-		])
-		ADAPTER_VAR([adapter])=no
-	])
-	AM_CONDITIONAL(ADAPTER_SYM([adapter]), [test "x$ADAPTER_VAR([adapter])" != "xno"])
-  ])
-])
-
-PROCESS_ADAPTERS([USB1_ADAPTERS], ["x$use_libusb1" = "xyes"], [libusb-1.x])
-PROCESS_ADAPTERS([USB_ADAPTERS], ["x$use_libusb1" = "xyes" -o "x$use_libusb0" = "xyes"], [libusb-1.x or libusb-0.1])
-PROCESS_ADAPTERS([USB0_ADAPTERS], ["x$use_libusb0" = "xyes"], [libusb-0.1])
-PROCESS_ADAPTERS([HIDAPI_ADAPTERS], ["x$use_hidapi" = "xyes"], [hidapi])
-PROCESS_ADAPTERS([HIDAPI_USB1_ADAPTERS], ["x$use_hidapi" = "xyes" -a "x$use_libusb1" = "xyes"], [hidapi and libusb-1.x])
-PROCESS_ADAPTERS([LIBFTDI_ADAPTERS], ["x$use_libftdi" = "xyes"], [libftdi])
-PROCESS_ADAPTERS([LIBJAYLINK_ADAPTERS], ["x$use_internal_libjaylink" = "xyes" -o "x$use_libjaylink" = "xyes"], [libjaylink-0.2])
-
-AS_IF([test "x$build_openjtag" = "xyes"], [
-  AS_IF([test "x$use_libusb1" != "xyes" -a "x$use_libusb0" != "xyes"], [
-    AC_MSG_ERROR([libusb-1.x or libusb-0.1 is required for the OpenJTAG Programmer])
-    build_openjtag=no
-  ])
-])
-
-AS_IF([test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"], [
-	AC_DEFINE([BUILD_HLADAPTER], [1], [1 if you want the High Level JTAG driver.])
-], [
-	AC_DEFINE([BUILD_HLADAPTER], [0], [0 if you want the High Level JTAG driver.])
-])
-AM_CONDITIONAL([HLADAPTER], [test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"])
-
-AS_IF([test "x$enable_jlink" != "xno"], [
-  AS_IF([test "x$use_internal_libjaylink" = "xyes"], [
-    AS_IF([test -f "$srcdir/src/jtag/drivers/libjaylink/configure.ac"], [
-      AX_CONFIG_SUBDIR_OPTION([src/jtag/drivers/libjaylink],
-		[--enable-subproject-build])
-    ], [
-      AC_MSG_ERROR([Internal libjaylink not found, run either 'git submodule init' and 'git submodule update' or disable internal libjaylink with --disable-internal-libjaylink.])
-    ])
-  ])
-])
-
-# Presto needs the bitq module
-AS_IF([test "x$enable_presto" != "xno"], [
-  build_bitq=yes
-])
-
-AM_CONDITIONAL([RELEASE], [test "x$build_release" = "xyes"])
-AM_CONDITIONAL([PARPORT], [test "x$build_parport" = "xyes"])
-AM_CONDITIONAL([DUMMY], [test "x$build_dummy" = "xyes"])
-AM_CONDITIONAL([GIVEIO], [test "x$parport_use_giveio" = "xyes"])
-AM_CONDITIONAL([EP93XX], [test "x$build_ep93xx" = "xyes"])
-AM_CONDITIONAL([ZY1000], [test "x$build_zy1000" = "xyes"])
-AM_CONDITIONAL([ZY1000_MASTER], [test "x$build_zy1000_master" = "xyes"])
-AM_CONDITIONAL([IOUTIL], [test "x$build_ioutil" = "xyes"])
-AM_CONDITIONAL([AT91RM9200], [test "x$build_at91rm9200" = "xyes"])
-AM_CONDITIONAL([BCM2835GPIO], [test "x$build_bcm2835gpio" = "xyes"])
-AM_CONDITIONAL([IMX_GPIO], [test "x$build_imx_gpio" = "xyes"])
-AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
-AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes" -o "x$build_jtag_vpi" = "xyes"])
-AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
-AM_CONDITIONAL([AMTJTAGACCEL], [test "x$build_amtjtagaccel" = "xyes"])
-AM_CONDITIONAL([GW16012], [test "x$build_gw16012" = "xyes"])
-AM_CONDITIONAL([OOCD_TRACE], [test "x$build_oocd_trace" = "xyes"])
-AM_CONDITIONAL([REMOTE_BITBANG], [test "x$build_remote_bitbang" = "xyes"])
-AM_CONDITIONAL([BUSPIRATE], [test "x$build_buspirate" = "xyes"])
-AM_CONDITIONAL([SYSFSGPIO], [test "x$build_sysfsgpio" = "xyes"])
-AM_CONDITIONAL([USE_LIBUSB0], [test "x$use_libusb0" = "xyes"])
-AM_CONDITIONAL([USE_LIBUSB1], [test "x$use_libusb1" = "xyes"])
-AM_CONDITIONAL([IS_CYGWIN], [test "x$is_cygwin" = "xyes"])
-AM_CONDITIONAL([IS_MINGW], [test "x$is_mingw" = "xyes"])
-AM_CONDITIONAL([IS_WIN32], [test "x$is_win32" = "xyes"])
-AM_CONDITIONAL([IS_DARWIN], [test "x$is_darwin" = "xyes"])
-AM_CONDITIONAL([BITQ], [test "x$build_bitq" = "xyes"])
-AM_CONDITIONAL([USE_LIBFTDI], [test "x$use_libftdi" = "xyes"])
-AM_CONDITIONAL([USE_HIDAPI], [test "x$use_hidapi" = "xyes"])
-AM_CONDITIONAL([USE_LIBJAYLINK], [test "x$use_libjaylink" = "xyes"])
-AM_CONDITIONAL([TARGET64], [test "x$build_target64" = "xyes"])
-
-AM_CONDITIONAL([MINIDRIVER], [test "x$build_minidriver" = "xyes"])
-AM_CONDITIONAL([MINIDRIVER_DUMMY], [test "x$build_minidriver_dummy" = "xyes"])
-
-AM_CONDITIONAL([INTERNAL_JIMTCL], [test "x$use_internal_jimtcl" = "xyes"])
-AM_CONDITIONAL([INTERNAL_LIBJAYLINK], [test "x$use_internal_libjaylink" = "xyes"])
-
-# Look for environ alternatives.  Possibility #1: is environ in unistd.h or stdlib.h?
-AC_MSG_CHECKING([for environ in unistd.h and stdlib.h])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#define _GNU_SOURCE
-#include <unistd.h>
-#include <stdlib.h>
-  ]], [[char **ep = environ;]]
-  )], [
-    AC_MSG_RESULT([yes])
-    has_environ=yes
-  ], [
-    AC_MSG_RESULT([no])
-
-    # Possibility #2: can environ be found in an available library?
-    AC_MSG_CHECKING([for extern environ])
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-    extern char **environ;
-    ]], [[char **ep = environ;]]
-      )], [
-        AC_DEFINE(NEED_ENVIRON_EXTERN, [1], [Must declare 'environ' to use it.])
-        has_environ=yes
-      ], [
-        has_environ=no
-      ])
-    AC_MSG_RESULT([${has_environ}])
-  ])
-
-AS_IF([test "x${has_environ}" != "xyes" ], [
-  AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.])
-])
-
-AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])
-
-# set default gcc warnings
-GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security -Wshadow"
-AS_IF([test "x${gcc_wextra}" = "xyes"], [
-  GCC_WARNINGS="${GCC_WARNINGS} -Wextra -Wno-unused-parameter"
-  GCC_WARNINGS="${GCC_WARNINGS} -Wbad-function-cast"
-  GCC_WARNINGS="${GCC_WARNINGS} -Wcast-align"
-  GCC_WARNINGS="${GCC_WARNINGS} -Wredundant-decls"
-])
-AS_IF([test "x${gcc_werror}" = "xyes"], [
-  GCC_WARNINGS="${GCC_WARNINGS} -Werror"
-])
-
-# overide default gcc cflags
-AS_IF([test "x$gcc_warnings" = "xyes"], [
-  AC_SUBST([GCC_WARNINGS], [$GCC_WARNINGS])
-])
-
-AC_CONFIG_FILES([
-  Makefile
-])
-AC_OUTPUT
-
-echo
-echo
-echo OpenOCD configuration summary
-echo --------------------------------------------------
-m4_foreach([adapter], [USB1_ADAPTERS, USB_ADAPTERS, USB0_ADAPTERS,
-	HIDAPI_ADAPTERS, HIDAPI_USB1_ADAPTERS, LIBFTDI_ADAPTERS,
-	LIBJAYLINK_ADAPTERS],
-	[s=m4_format(["%-40s"], ADAPTER_DESC([adapter]))
-	AS_CASE([$ADAPTER_VAR([adapter])],
-		[auto], [
-			echo "$s"yes '(auto)'
-		],
-		[yes], [
-			echo "$s"yes
-		],
-		[no], [
-			echo "$s"no
-	])
-])
-echo
-
-AS_IF([test "x$build_oocd_trace" = "xyes"], [
-  echo 'WARNING! Deprecated configure option (--enable-oocd_trace)'
-  echo 'The oocd_trace driver is deprecated and will be removed in the next release.'
-  echo 'If you regularly use this driver, please report to the OpenOCD Mailing List.'
-  echo
-])
-
-AS_IF([test "x$build_zy1000" = "xyes" -o "x$build_zy1000_master" = "xyes"], [
-  echo 'WARNING! Deprecated configure option (--enable-zy1000, --enable-zy1000-master)'
-  echo 'Support for the ZY1000 platform is deprecated and will be removed in the next'
-  echo 'release. If you regularly use this platform, please report to the OpenOCD'
-  echo 'Mailing List.'
-  echo
-])
-
-AS_IF([test "x$build_ioutil" = "xyes"], [
-  echo 'WARNING! Deprecated configure option (--enable-ioutil)'
-  echo 'Support for the ioutil functions is deprecated and will be removed in the next'
-  echo 'release. If you regularly depend on this functionality, please report to the'
-  echo 'OpenOCD Mailing List.'
-  echo
-])
+AC_PREREQ(2.64)
+AC_INIT([openocd], [0.10.0+dev],
+  [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
+AC_CONFIG_SRCDIR([src/openocd.c])
+
+m4_include([config_subdir.m4])dnl
+
+# check for makeinfo before calling AM_INIT_AUTOMAKE
+AC_CHECK_PROG([MAKEINFO], [makeinfo], [makeinfo])
+AS_IF([test "x$MAKEINFO" = "x"], [
+  MAKEINFO='echo makeinfo missing; true'
+  AC_MSG_WARN([Info documentation will not be built.])
+])
+AC_SUBST([MAKEINFO])
+
+AM_INIT_AUTOMAKE([-Wall -Wno-portability dist-bzip2 dist-zip subdir-objects])
+
+AC_CONFIG_HEADERS([config.h])
+AH_BOTTOM([
+#include <helper/system.h>
+#include <helper/types.h>
+#include <helper/replacements.h>
+])
+
+AC_LANG_C
+AC_PROG_CC
+AC_PROG_CC_C99
+AM_PROG_CC_C_O
+AC_PROG_RANLIB
+PKG_PROG_PKG_CONFIG([0.23])
+
+dnl disable checks for C++, Fortran and GNU Java Compiler
+m4_defun([_LT_AC_LANG_CXX_CONFIG], [:])
+m4_defun([_LT_AC_LANG_F77_CONFIG], [:])
+m4_defun([_LT_AC_LANG_GCJ_CONFIG], [:])
+AC_DISABLE_SHARED
+AC_PROG_LIBTOOL
+AC_SUBST([LIBTOOL_DEPS])
+
+dnl configure checks required for Jim files (these are obsolete w/ C99)
+AC_C_CONST
+AC_TYPE_LONG_LONG_INT
+
+AC_SEARCH_LIBS([ioperm], [ioperm])
+AC_SEARCH_LIBS([dlopen], [dl])
+
+AC_CHECK_HEADERS([sys/socket.h])
+AC_CHECK_HEADERS([elf.h])
+AC_CHECK_HEADERS([dirent.h])
+AC_CHECK_HEADERS([fcntl.h])
+AC_CHECK_HEADERS([malloc.h])
+AC_CHECK_HEADERS([netdb.h])
+AC_CHECK_HEADERS([poll.h])
+AC_CHECK_HEADERS([pthread.h])
+AC_CHECK_HEADERS([strings.h])
+AC_CHECK_HEADERS([sys/ioctl.h])
+AC_CHECK_HEADERS([sys/param.h])
+AC_CHECK_HEADERS([sys/select.h])
+AC_CHECK_HEADERS([sys/stat.h])
+AC_CHECK_HEADERS([sys/sysctl.h])
+AC_CHECK_HEADERS([sys/time.h])
+AC_CHECK_HEADERS([sys/types.h])
+AC_CHECK_HEADERS([unistd.h])
+AC_CHECK_HEADERS([arpa/inet.h ifaddrs.h netinet/in.h netinet/tcp.h net/if.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+
+AC_HEADER_ASSERT
+AC_HEADER_STDBOOL
+AC_HEADER_TIME
+
+AC_C_BIGENDIAN
+
+AC_CHECK_FUNCS([strndup])
+AC_CHECK_FUNCS([strnlen])
+AC_CHECK_FUNCS([gettimeofday])
+AC_CHECK_FUNCS([usleep])
+AC_CHECK_FUNCS([vasprintf])
+AC_CHECK_FUNCS([realpath])
+
+# guess-rev.sh only exists in the repository, not in the released archives
+AC_MSG_CHECKING([whether to build a release])
+AS_IF([test -x "$srcdir/guess-rev.sh"], [
+  build_release=no
+], [
+  build_release=yes
+])
+AC_MSG_RESULT([$build_release])
+
+# Adapter drivers
+# 1st column -- configure option
+# 2nd column -- description
+# 3rd column -- symbol used for both config.h and automake
+m4_define([ADAPTER_ARG], [m4_argn([1], $1)])
+m4_define([ADAPTER_DESC], [m4_argn([2], $1)])
+m4_define([ADAPTER_SYM], [m4_argn([3], $1)])
+m4_define([ADAPTER_VAR], [enable_[]ADAPTER_ARG($1)])
+m4_define([ADAPTER_OPT], [m4_translit(ADAPTER_ARG($1), [_], [-])])
+
+m4_define([USB1_ADAPTERS],
+	[[[ftdi], [MPSSE mode of FTDI based devices], [FTDI]],
+	[[lscc_cableserver], [Lattice USB cableserver], [LSCC_USB_CABLESERVER]],
+	[[stlink], [ST-Link JTAG Programmer], [HLADAPTER_STLINK]],
+	[[ti_icdi], [TI ICDI JTAG Programmer], [HLADAPTER_ICDI]],
+	[[ulink], [Keil ULINK JTAG Programmer], [ULINK]],
+	[[usb_blaster_2], [Altera USB-Blaster II Compatible], [USB_BLASTER_2]],
+	[[ft232r], [Bitbang mode of FT232R based devices], [FT232R]],
+	[[vsllink], [Versaloon-Link JTAG Programmer], [VSLLINK]],
+	[[xds110], [TI XDS110 Debug Probe], [XDS110]]])
+
+m4_define([USB_ADAPTERS],
+	[[[osbdm], [OSBDM (JTAG only) Programmer], [OSBDM]],
+	[[opendous], [eStick/opendous JTAG Programmer], [OPENDOUS]],
+	[[aice], [Andes JTAG Programmer], [AICE]]])
+
+m4_define([USB0_ADAPTERS],
+	[[[usbprog], [USBProg JTAG Programmer], [USBPROG]],
+	[[rlink], [Raisonance RLink JTAG Programmer], [RLINK]],
+	[[armjtagew], [Olimex ARM-JTAG-EW Programmer], [ARMJTAGEW]]])
+
+m4_define([HIDAPI_ADAPTERS],
+	[[[cmsis_dap], [CMSIS-DAP Compliant Debugger], [CMSIS_DAP]]])
+
+m4_define([HIDAPI_USB1_ADAPTERS],
+	[[[kitprog], [Cypress KitProg Programmer], [KITPROG]]])
+
+m4_define([LIBFTDI_ADAPTERS],
+	[[[usb_blaster], [Altera USB-Blaster Compatible], [USB_BLASTER]],
+	[[presto], [ASIX Presto Adapter], [PRESTO]],
+	[[openjtag], [OpenJTAG Adapter], [OPENJTAG]]])
+
+m4_define([LIBJAYLINK_ADAPTERS],
+	[[[jlink], [SEGGER J-Link Programmer], [JLINK]]])
+
+
+AC_ARG_ENABLE([doxygen-html],
+  AS_HELP_STRING([--disable-doxygen-html],
+    [Disable building Doxygen manual as HTML.]),
+  [doxygen_as_html=$enableval], [doxygen_as_html=yes])
+AC_SUBST([doxygen_as_html])
+AC_MSG_CHECKING([whether to build Doxygen as HTML])
+AC_MSG_RESULT([$doxygen_as_html])
+
+AC_ARG_ENABLE([doxygen-pdf],
+  AS_HELP_STRING([--enable-doxygen-pdf],
+    [Enable building Doxygen manual as PDF.]),
+  [doxygen_as_pdf=$enableval], [doxygen_as_pdf=no])
+AC_SUBST([doxygen_as_pdf])
+AC_MSG_CHECKING([whether to build Doxygen as PDF])
+AC_MSG_RESULT([$doxygen_as_pdf])
+
+AC_ARG_ENABLE([gccwarnings],
+  AS_HELP_STRING([--disable-gccwarnings], [Disable compiler warnings]),
+  [gcc_warnings=$enableval], [gcc_warnings=yes])
+
+AC_ARG_ENABLE([wextra],
+  AS_HELP_STRING([--disable-wextra], [Disable extra compiler warnings]),
+  [gcc_wextra=$enableval], [gcc_wextra=$gcc_warnings])
+
+AC_ARG_ENABLE([werror],
+  AS_HELP_STRING([--disable-werror], [Do not treat warnings as errors]),
+  [gcc_werror=$enableval], [gcc_werror=$gcc_warnings])
+
+# set default verbose options, overridden by following options
+debug_jtag_io=no
+debug_usb_io=no
+debug_usb_comms=no
+
+AC_ARG_ENABLE([verbose],
+  AS_HELP_STRING([--enable-verbose],
+      [Enable verbose JTAG I/O messages (for debugging).]),
+  [
+  debug_jtag_io=$enableval
+  debug_usb_io=$enableval
+  debug_usb_comms=$enableval
+  ], [])
+
+AC_ARG_ENABLE([verbose_jtag_io],
+  AS_HELP_STRING([--enable-verbose-jtag-io],
+      [Enable verbose JTAG I/O messages (for debugging).]),
+  [debug_jtag_io=$enableval], [])
+
+AC_ARG_ENABLE([verbose_usb_io],
+  AS_HELP_STRING([--enable-verbose-usb-io],
+      [Enable verbose USB I/O messages (for debugging)]),
+  [debug_usb_io=$enableval], [])
+
+AC_ARG_ENABLE([verbose_usb_comms],
+  AS_HELP_STRING([--enable-verbose-usb-comms],
+      [Enable verbose USB communication messages (for debugging)]),
+  [debug_usb_comms=$enableval], [])
+
+AC_MSG_CHECKING([whether to enable verbose JTAG I/O messages]);
+AC_MSG_RESULT([$debug_jtag_io])
+AS_IF([test "x$debug_jtag_io" = "xyes"], [
+  AC_DEFINE([_DEBUG_JTAG_IO_],[1], [Print verbose JTAG I/O messages])
+])
+
+AC_MSG_CHECKING([whether to enable verbose USB I/O messages]);
+AC_MSG_RESULT([$debug_usb_io])
+AS_IF([test "x$debug_usb_io" = "xyes"], [
+  AC_DEFINE([_DEBUG_USB_IO_],[1], [Print verbose USB I/O messages])
+])
+
+AC_MSG_CHECKING([whether to enable verbose USB communication messages]);
+AC_MSG_RESULT([$debug_usb_comms])
+AS_IF([test "x$debug_usb_comms" = "xyes"], [
+  AC_DEFINE([_DEBUG_USB_COMMS_],[1], [Print verbose USB communication messages])
+])
+
+debug_malloc=no
+AC_ARG_ENABLE([malloc_logging],
+  AS_HELP_STRING([--enable-malloc-logging],
+      [Include free space in logging messages (requires malloc.h).]),
+  [debug_malloc=$enableval], [])
+
+AC_MSG_CHECKING([whether to enable malloc free space logging]);
+AC_MSG_RESULT([$debug_malloc])
+AS_IF([test "x$debug_malloc" = "xyes"], [
+  AC_DEFINE([_DEBUG_FREE_SPACE_],[1], [Include malloc free space in logging])
+])
+
+AC_ARG_ENABLE([dummy],
+  AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]),
+  [build_dummy=$enableval], [build_dummy=no])
+
+m4_define([AC_ARG_ADAPTERS], [
+  m4_foreach([adapter], [$1],
+	[AC_ARG_ENABLE(ADAPTER_OPT([adapter]),
+		AS_HELP_STRING([--enable-ADAPTER_OPT([adapter])],
+			[Enable building support for the ]ADAPTER_DESC([adapter])[ (default is $2)]),
+		[], [ADAPTER_VAR([adapter])=$2])
+  ])
+])
+
+AC_ARG_ADAPTERS([
+  USB1_ADAPTERS,
+  USB_ADAPTERS,
+  USB0_ADAPTERS,
+  HIDAPI_ADAPTERS,
+  HIDAPI_USB1_ADAPTERS,
+  LIBFTDI_ADAPTERS,
+  LIBJAYLINK_ADAPTERS
+  ],[auto])
+
+AC_ARG_ENABLE([parport],
+  AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
+  [build_parport=$enableval], [build_parport=no])
+
+AC_ARG_ENABLE([parport_ppdev],
+  AS_HELP_STRING([--disable-parport-ppdev],
+      [Disable use of ppdev (/dev/parportN) for parport (for x86 only)]),
+    [parport_use_ppdev=$enableval], [parport_use_ppdev=yes])
+
+AC_ARG_ENABLE([parport_giveio],
+    AS_HELP_STRING([--enable-parport-giveio],
+      [Enable use of giveio for parport (for CygWin only)]),
+    [parport_use_giveio=$enableval], [parport_use_giveio=])
+
+AC_ARG_ENABLE([jtag_vpi],
+  AS_HELP_STRING([--enable-jtag_vpi], [Enable building support for JTAG VPI]),
+  [build_jtag_vpi=$enableval], [build_jtag_vpi=no])
+
+AC_ARG_ENABLE([amtjtagaccel],
+  AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
+  [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
+
+AC_ARG_ENABLE([zy1000_master],
+  AS_HELP_STRING([--enable-zy1000-master], [Use ZY1000 JTAG master registers]),
+  [build_zy1000_master=$enableval], [build_zy1000_master=no])
+
+AC_ARG_ENABLE([zy1000],
+  AS_HELP_STRING([--enable-zy1000], [Enable ZY1000 interface]),
+  [build_zy1000=$enableval], [build_zy1000=no])
+
+AC_ARG_ENABLE([ioutil],
+  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]),
+  [build_ioutil=$enableval], [build_ioutil=no])
+
+AS_CASE(["${host_cpu}"],
+  [arm*], [
+    AC_ARG_ENABLE([ep93xx],
+      AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]),
+      [build_ep93xx=$enableval], [build_ep93xx=no])
+
+    AC_ARG_ENABLE([at91rm9200],
+      AS_HELP_STRING([--enable-at91rm9200], [Enable building support for AT91RM9200 based SBCs]),
+      [build_at91rm9200=$enableval], [build_at91rm9200=no])
+
+    AC_ARG_ENABLE([bcm2835gpio],
+      AS_HELP_STRING([--enable-bcm2835gpio], [Enable building support for bitbanging on BCM2835 (as found in Raspberry Pi)]),
+      [build_bcm2835gpio=$enableval], [build_bcm2835gpio=no])
+    AC_ARG_ENABLE([imx_gpio],
+      AS_HELP_STRING([--enable-imx_gpio], [Enable building support for bitbanging on NXP IMX processors]),
+      [build_imx_gpio=$enableval], [build_imx_gpio=no])
+  ],
+  [
+    build_ep93xx=no
+    build_at91rm9200=no
+    build_bcm2835gpio=no
+    build_imx_gpio=no
+])
+
+AC_ARG_ENABLE([gw16012],
+  AS_HELP_STRING([--enable-gw16012], [Enable building support for the Gateworks GW16012 JTAG Programmer]),
+  [build_gw16012=$enableval], [build_gw16012=no])
+
+AC_ARG_ENABLE([oocd_trace],
+  AS_HELP_STRING([--enable-oocd_trace],
+  [Enable building support for some prototype OpenOCD+trace ETM capture hardware]),
+  [build_oocd_trace=$enableval], [build_oocd_trace=no])
+
+AC_ARG_ENABLE([buspirate],
+  AS_HELP_STRING([--enable-buspirate], [Enable building support for the Buspirate]),
+  [build_buspirate=$enableval], [build_buspirate=no])
+
+AC_ARG_ENABLE([sysfsgpio],
+  AS_HELP_STRING([--enable-sysfsgpio], [Enable building support for programming driven via sysfs gpios.]),
+  [build_sysfsgpio=$enableval], [build_sysfsgpio=no])
+
+AS_CASE([$host_os],
+  [linux*], [],
+  [
+    AS_IF([test "x$build_sysfsgpio" = "xyes"], [
+      AC_MSG_ERROR([sysfsgpio is only available on linux])
+    ])
+])
+
+AC_ARG_ENABLE([minidriver_dummy],
+  AS_HELP_STRING([--enable-minidriver-dummy], [Enable the dummy minidriver.]),
+  [build_minidriver_dummy=$enableval], [build_minidriver_dummy=no])
+
+AC_ARG_ENABLE([internal-jimtcl],
+  AS_HELP_STRING([--disable-internal-jimtcl], [Disable building internal jimtcl]),
+  [use_internal_jimtcl=$enableval], [use_internal_jimtcl=yes])
+
+AC_ARG_ENABLE([internal-libjaylink],
+  AS_HELP_STRING([--disable-internal-libjaylink],
+  [Disable building internal libjaylink]),
+  [use_internal_libjaylink=$enableval], [use_internal_libjaylink=yes])
+
+AC_ARG_ENABLE([target64],
+  AS_HELP_STRING([--disable-target64], [Disable 64-bit target address]),
+    [build_target64=$enableval], [build_target64=yes])
+
+build_minidriver=no
+AC_MSG_CHECKING([whether to enable ZY1000 minidriver])
+AS_IF([test "x$build_zy1000" = "xyes"], [
+  AS_IF([test "x$build_minidriver" = "xyes"], [
+    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
+  ])
+  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
+      [Define to 1 if you have the <jtag_minidriver.h> header file.])
+  build_minidriver=yes
+])
+AC_MSG_RESULT([$build_zy1000])
+
+AC_ARG_ENABLE([remote-bitbang],
+  AS_HELP_STRING([--enable-remote-bitbang], [Enable building support for the Remote Bitbang jtag driver]),
+  [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
+
+AC_MSG_CHECKING([whether to enable dummy minidriver])
+AS_IF([test "x$build_minidriver_dummy" = "xyes"], [
+  AS_IF([test "x$build_minidriver" = "xyes"], [
+    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
+  ])
+  build_minidriver=yes
+  AC_DEFINE([BUILD_MINIDRIVER_DUMMY], [1], [Use the dummy minidriver.])
+  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
+      [Define to 1 if you have the <jtag_minidriver.h> header file.])
+])
+AC_MSG_RESULT([$build_minidriver_dummy])
+
+AC_MSG_CHECKING([whether standard drivers can be built])
+AS_IF([test "x$build_minidriver" = "xyes"], [
+  AC_MSG_RESULT([no])
+  AC_MSG_WARN([Using the minidriver disables all other drivers.])
+  sleep 2
+], [
+  AC_MSG_RESULT([yes])
+])
+
+AS_CASE(["${host_cpu}"],
+  [i?86|x86*], [],
+  [
+    AS_IF([test "x$parport_use_ppdev" = "xno"], [
+      AC_MSG_WARN([--disable-parport-ppdev is not supported by the host CPU])
+    ])
+    parport_use_ppdev=yes
+])
+
+AS_CASE([$host],
+  [*-cygwin*], [
+    is_win32=yes
+    parport_use_ppdev=no
+
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[return __MINGW32__;]])],
+      [is_mingw=yes],[is_mingw=no])
+    AS_IF([test "x$is_mingw" = "xyes"], [
+      AS_IF([test "x$parport_use_giveio" = "xno"], [
+        AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
+      ])
+      parport_use_giveio=yes
+      is_cygwin=no
+    ], [
+      is_cygwin=yes
+      # sys/io.h needed under cygwin for parport access
+      AS_IF([test "x$build_parport" = "xyes"], [
+        AC_CHECK_HEADERS([sys/io.h],[],AC_MSG_ERROR([Please install the cygwin ioperm package]))
+      ])
+    ])
+  ],
+  [*-mingw* | *-msys*], [
+    is_mingw=yes
+    is_win32=yes
+    parport_use_ppdev=no
+
+    AS_IF([test "x$parport_use_giveio" = "xno"], [
+      AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
+    ])
+    parport_use_giveio=yes
+
+    AS_IF([test "x$build_buspirate" = "xyes"], [
+      AC_MSG_ERROR([buspirate currently not supported by MinGW32 hosts])
+    ])
+
+    AC_SUBST([HOST_CPPFLAGS], [-D__USE_MINGW_ANSI_STDIO])
+  ],
+  [*darwin*], [
+    is_darwin=yes
+
+    AS_IF([test "x$parport_use_giveio" = "xyes"], [
+      AC_MSG_WARN([--enable-parport-giveio cannot be used by Darwin hosts])
+    ])
+    parport_use_giveio=no
+  ],
+  [
+    AS_IF([test "x$parport_use_giveio" = "xyes"], [
+      AC_MSG_WARN([--enable-parport-giveio cannot be used by ]$host[ hosts])
+    ])
+    parport_use_giveio=no
+])
+
+AS_IF([test "x$is_cygwin" = "xyes"], [
+    AC_DEFINE([IS_CYGWIN], [1], [1 if building for Cygwin.])
+], [
+    AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
+])
+
+AS_IF([test "x$is_mingw" = "xyes"], [
+    AC_DEFINE([IS_MINGW], [1], [1 if building for Mingw.])
+], [
+    AC_DEFINE([IS_MINGW], [0], [0 if not building for Mingw.])
+])
+
+AS_IF([test "x$is_win32" = "xyes"], [
+    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
+], [
+    AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
+])
+
+AS_IF([test "x$is_darwin" = "xyes"], [
+    AC_DEFINE([IS_DARWIN], [1], [1 if building for Darwin.])
+], [
+    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
+])
+
+AS_IF([test "x$build_parport" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_PARPORT], [1], [1 if you want parport.])
+], [
+  AC_DEFINE([BUILD_PARPORT], [0], [0 if you don't want parport.])
+])
+
+AS_IF([test "x$build_dummy" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_DUMMY], [1], [1 if you want dummy driver.])
+], [
+  AC_DEFINE([BUILD_DUMMY], [0], [0 if you don't want dummy driver.])
+])
+
+AS_IF([test "x$build_ep93xx" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_EP93XX], [1], [1 if you want ep93xx.])
+], [
+  AC_DEFINE([BUILD_EP93XX], [0], [0 if you don't want ep93xx.])
+])
+
+AS_IF([test "x$build_zy1000" = "xyes"], [
+  AC_DEFINE([BUILD_ZY1000], [1], [1 if you want ZY1000.])
+], [
+  AC_DEFINE([BUILD_ZY1000], [0], [0 if you don't want ZY1000.])
+])
+
+AS_IF([test "x$build_zy1000_master" = "xyes"], [
+  AC_DEFINE([BUILD_ZY1000_MASTER], [1], [1 if you want ZY1000 JTAG master registers.])
+], [
+  AC_DEFINE([BUILD_ZY1000_MASTER], [0], [0 if you don't want ZY1000 JTAG master registers.])
+])
+
+AS_IF([test "x$build_at91rm9200" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_AT91RM9200], [1], [1 if you want at91rm9200.])
+], [
+  AC_DEFINE([BUILD_AT91RM9200], [0], [0 if you don't want at91rm9200.])
+])
+
+AS_IF([test "x$build_bcm2835gpio" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_BCM2835GPIO], [1], [1 if you want bcm2835gpio.])
+], [
+  AC_DEFINE([BUILD_BCM2835GPIO], [0], [0 if you don't want bcm2835gpio.])
+])
+
+AS_IF([test "x$build_imx_gpio" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX_GPIO], [1], [1 if you want imx_gpio.])
+], [
+  AC_DEFINE([BUILD_IMX_GPIO], [0], [0 if you don't want imx_gpio.])
+])
+
+AS_IF([test "x$parport_use_ppdev" = "xyes"], [
+  AC_DEFINE([PARPORT_USE_PPDEV], [1], [1 if you want parport to use ppdev.])
+], [
+  AC_DEFINE([PARPORT_USE_PPDEV], [0], [0 if you don't want parport to use ppdev.])
+])
+
+AS_IF([test "x$parport_use_giveio" = "xyes"], [
+  AC_DEFINE([PARPORT_USE_GIVEIO], [1], [1 if you want parport to use giveio.])
+], [
+  AC_DEFINE([PARPORT_USE_GIVEIO], [0], [0 if you don't want parport to use giveio.])
+])
+
+AS_IF([test "x$build_jtag_vpi" = "xyes"], [
+  AC_DEFINE([BUILD_JTAG_VPI], [1], [1 if you want JTAG VPI.])
+], [
+  AC_DEFINE([BUILD_JTAG_VPI], [0], [0 if you don't want JTAG VPI.])
+])
+
+AS_IF([test "x$build_amtjtagaccel" = "xyes"], [
+  AC_DEFINE([BUILD_AMTJTAGACCEL], [1], [1 if you want the Amontec JTAG-Accelerator driver.])
+], [
+  AC_DEFINE([BUILD_AMTJTAGACCEL], [0], [0 if you don't want the Amontec JTAG-Accelerator driver.])
+])
+
+AS_IF([test "x$build_gw16012" = "xyes"], [
+  AC_DEFINE([BUILD_GW16012], [1], [1 if you want the Gateworks GW16012 driver.])
+], [
+  AC_DEFINE([BUILD_GW16012], [0], [0 if you don't want the Gateworks GW16012 driver.])
+])
+
+AS_IF([test "x$build_oocd_trace" = "xyes"], [
+  AC_DEFINE([BUILD_OOCD_TRACE], [1], [1 if you want the OpenOCD+trace ETM capture driver.])
+], [
+  AC_DEFINE([BUILD_OOCD_TRACE], [0], [0 if you don't want the OpenOCD+trace ETM capture driver.])
+])
+
+AS_IF([test "x$build_buspirate" = "xyes"], [
+  AC_DEFINE([BUILD_BUSPIRATE], [1], [1 if you want the Buspirate JTAG driver.])
+], [
+  AC_DEFINE([BUILD_BUSPIRATE], [0], [0 if you don't want the Buspirate JTAG driver.])
+])
+
+AS_IF([test "x$use_internal_jimtcl" = "xyes"], [
+  AS_IF([test -f "$srcdir/jimtcl/configure.ac"], [
+    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
+  ], [
+    AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
+  ])
+])
+
+AS_IF([test "x$build_remote_bitbang" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_REMOTE_BITBANG], [1], [1 if you want the Remote Bitbang JTAG driver.])
+], [
+  AC_DEFINE([BUILD_REMOTE_BITBANG], [0], [0 if you don't want the Remote Bitbang JTAG driver.])
+])
+
+AS_IF([test "x$build_sysfsgpio" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_SYSFSGPIO], [1], [1 if you want the SysfsGPIO driver.])
+], [
+  AC_DEFINE([BUILD_SYSFSGPIO], [0], [0 if you don't want SysfsGPIO driver.])
+])
+
+AS_IF([test "x$build_target64" = "xyes"], [
+  AC_DEFINE([BUILD_TARGET64], [1], [1 if you want 64-bit addresses.])
+], [
+  AC_DEFINE([BUILD_TARGET64], [0], [0 if you don't want 64-bit addresses.])
+])
+
+
+PKG_CHECK_MODULES([LIBUSB1], [libusb-1.0], [
+	use_libusb1=yes
+	AC_DEFINE([HAVE_LIBUSB1], [1], [Define if you have libusb-1.x])
+	PKG_CHECK_EXISTS([libusb-1.0 >= 1.0.9],
+		[AC_DEFINE([HAVE_LIBUSB_ERROR_NAME], [1], [Define if your libusb has libusb_error_name()])],
+		[AC_MSG_WARN([libusb-1.x older than 1.0.9 detected, consider updating])])
+	LIBUSB1_CFLAGS=`echo $LIBUSB1_CFLAGS | sed 's/-I/-isystem /'`
+	AC_MSG_NOTICE([libusb-1.0 header bug workaround: LIBUSB1_CFLAGS changed to "$LIBUSB1_CFLAGS"])
+	PKG_CHECK_EXISTS([libusb-1.0 >= 1.0.16],
+		[AC_DEFINE([HAVE_LIBUSB_GET_PORT_NUMBERS], [1], [Define if your libusb has libusb_get_port_numbers()])])
+  ], [
+	use_libusb1=no
+	AC_MSG_WARN([libusb-1.x not found, trying legacy libusb-0.1 as a fallback; consider installing libusb-1.x instead])
+])
+
+PKG_CHECK_MODULES([LIBUSB0], [libusb], [use_libusb0=yes], [use_libusb0=no])
+
+for hidapi_lib in hidapi hidapi-hidraw hidapi-libusb; do
+	PKG_CHECK_MODULES([HIDAPI],[$hidapi_lib],[
+		use_hidapi=yes
+		break
+	],[
+		use_hidapi=no
+	])
+done
+
+PKG_CHECK_MODULES([LIBFTDI], [libftdi1], [use_libftdi=yes], [
+	PKG_CHECK_MODULES([LIBFTDI], [libftdi], [use_libftdi=yes], [use_libftdi=no])
+])
+
+PKG_CHECK_MODULES([LIBJAYLINK], [libjaylink >= 0.2],
+	[use_libjaylink=yes], [use_libjaylink=no])
+
+m4_define([PROCESS_ADAPTERS], [
+  m4_foreach([adapter], [$1], [
+	AS_IF([test "x$build_zy1000" = "xyes"], [
+		ADAPTER_VAR([adapter])=no
+	])
+	AS_IF([test $2], [
+		AS_IF([test "x$ADAPTER_VAR([adapter])" != "xno"], [
+			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [1], [1 if you want the ]ADAPTER_DESC([adapter]).)
+		], [
+			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [0], [0 if you do not want the ]ADAPTER_DESC([adapter]).)
+		])
+	], [
+		AS_IF([test "x$ADAPTER_VAR([adapter])" = "xyes"], [
+			AC_MSG_ERROR([$3 is required for the ADAPTER_DESC([adapter])])
+		])
+		ADAPTER_VAR([adapter])=no
+	])
+	AM_CONDITIONAL(ADAPTER_SYM([adapter]), [test "x$ADAPTER_VAR([adapter])" != "xno"])
+  ])
+])
+
+PROCESS_ADAPTERS([USB1_ADAPTERS], ["x$use_libusb1" = "xyes"], [libusb-1.x])
+PROCESS_ADAPTERS([USB_ADAPTERS], ["x$use_libusb1" = "xyes" -o "x$use_libusb0" = "xyes"], [libusb-1.x or libusb-0.1])
+PROCESS_ADAPTERS([USB0_ADAPTERS], ["x$use_libusb0" = "xyes"], [libusb-0.1])
+PROCESS_ADAPTERS([HIDAPI_ADAPTERS], ["x$use_hidapi" = "xyes"], [hidapi])
+PROCESS_ADAPTERS([HIDAPI_USB1_ADAPTERS], ["x$use_hidapi" = "xyes" -a "x$use_libusb1" = "xyes"], [hidapi and libusb-1.x])
+PROCESS_ADAPTERS([LIBFTDI_ADAPTERS], ["x$use_libftdi" = "xyes"], [libftdi])
+PROCESS_ADAPTERS([LIBJAYLINK_ADAPTERS], ["x$use_internal_libjaylink" = "xyes" -o "x$use_libjaylink" = "xyes"], [libjaylink-0.2])
+
+AS_IF([test "x$build_openjtag" = "xyes"], [
+  AS_IF([test "x$use_libusb1" != "xyes" -a "x$use_libusb0" != "xyes"], [
+    AC_MSG_ERROR([libusb-1.x or libusb-0.1 is required for the OpenJTAG Programmer])
+    build_openjtag=no
+  ])
+])
+
+AS_IF([test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"], [
+	AC_DEFINE([BUILD_HLADAPTER], [1], [1 if you want the High Level JTAG driver.])
+], [
+	AC_DEFINE([BUILD_HLADAPTER], [0], [0 if you want the High Level JTAG driver.])
+])
+AM_CONDITIONAL([HLADAPTER], [test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"])
+
+AS_IF([test "x$enable_jlink" != "xno"], [
+  AS_IF([test "x$use_internal_libjaylink" = "xyes"], [
+    AS_IF([test -f "$srcdir/src/jtag/drivers/libjaylink/configure.ac"], [
+      AX_CONFIG_SUBDIR_OPTION([src/jtag/drivers/libjaylink],
+		[--enable-subproject-build])
+    ], [
+      AC_MSG_ERROR([Internal libjaylink not found, run either 'git submodule init' and 'git submodule update' or disable internal libjaylink with --disable-internal-libjaylink.])
+    ])
+  ])
+])
+
+# Presto needs the bitq module
+AS_IF([test "x$enable_presto" != "xno"], [
+  build_bitq=yes
+])
+
+AM_CONDITIONAL([RELEASE], [test "x$build_release" = "xyes"])
+AM_CONDITIONAL([PARPORT], [test "x$build_parport" = "xyes"])
+AM_CONDITIONAL([DUMMY], [test "x$build_dummy" = "xyes"])
+AM_CONDITIONAL([GIVEIO], [test "x$parport_use_giveio" = "xyes"])
+AM_CONDITIONAL([EP93XX], [test "x$build_ep93xx" = "xyes"])
+AM_CONDITIONAL([ZY1000], [test "x$build_zy1000" = "xyes"])
+AM_CONDITIONAL([ZY1000_MASTER], [test "x$build_zy1000_master" = "xyes"])
+AM_CONDITIONAL([IOUTIL], [test "x$build_ioutil" = "xyes"])
+AM_CONDITIONAL([AT91RM9200], [test "x$build_at91rm9200" = "xyes"])
+AM_CONDITIONAL([BCM2835GPIO], [test "x$build_bcm2835gpio" = "xyes"])
+AM_CONDITIONAL([IMX_GPIO], [test "x$build_imx_gpio" = "xyes"])
+AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
+AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes" -o "x$build_jtag_vpi" = "xyes"])
+AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
+AM_CONDITIONAL([LSCC_USB_CABLESERVER], [test "x$enable_lscc_usb_cableserver" != "xno"])
+AM_CONDITIONAL([AMTJTAGACCEL], [test "x$build_amtjtagaccel" = "xyes"])
+AM_CONDITIONAL([GW16012], [test "x$build_gw16012" = "xyes"])
+AM_CONDITIONAL([OOCD_TRACE], [test "x$build_oocd_trace" = "xyes"])
+AM_CONDITIONAL([REMOTE_BITBANG], [test "x$build_remote_bitbang" = "xyes"])
+AM_CONDITIONAL([BUSPIRATE], [test "x$build_buspirate" = "xyes"])
+AM_CONDITIONAL([SYSFSGPIO], [test "x$build_sysfsgpio" = "xyes"])
+AM_CONDITIONAL([USE_LIBUSB0], [test "x$use_libusb0" = "xyes"])
+AM_CONDITIONAL([USE_LIBUSB1], [test "x$use_libusb1" = "xyes"])
+AM_CONDITIONAL([IS_CYGWIN], [test "x$is_cygwin" = "xyes"])
+AM_CONDITIONAL([IS_MINGW], [test "x$is_mingw" = "xyes"])
+AM_CONDITIONAL([IS_WIN32], [test "x$is_win32" = "xyes"])
+AM_CONDITIONAL([IS_DARWIN], [test "x$is_darwin" = "xyes"])
+AM_CONDITIONAL([BITQ], [test "x$build_bitq" = "xyes"])
+AM_CONDITIONAL([USE_LIBFTDI], [test "x$use_libftdi" = "xyes"])
+AM_CONDITIONAL([USE_HIDAPI], [test "x$use_hidapi" = "xyes"])
+AM_CONDITIONAL([USE_LIBJAYLINK], [test "x$use_libjaylink" = "xyes"])
+AM_CONDITIONAL([TARGET64], [test "x$build_target64" = "xyes"])
+
+AM_CONDITIONAL([MINIDRIVER], [test "x$build_minidriver" = "xyes"])
+AM_CONDITIONAL([MINIDRIVER_DUMMY], [test "x$build_minidriver_dummy" = "xyes"])
+
+AM_CONDITIONAL([INTERNAL_JIMTCL], [test "x$use_internal_jimtcl" = "xyes"])
+AM_CONDITIONAL([INTERNAL_LIBJAYLINK], [test "x$use_internal_libjaylink" = "xyes"])
+
+# Look for environ alternatives.  Possibility #1: is environ in unistd.h or stdlib.h?
+AC_MSG_CHECKING([for environ in unistd.h and stdlib.h])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <stdlib.h>
+  ]], [[char **ep = environ;]]
+  )], [
+    AC_MSG_RESULT([yes])
+    has_environ=yes
+  ], [
+    AC_MSG_RESULT([no])
+
+    # Possibility #2: can environ be found in an available library?
+    AC_MSG_CHECKING([for extern environ])
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+    extern char **environ;
+    ]], [[char **ep = environ;]]
+      )], [
+        AC_DEFINE(NEED_ENVIRON_EXTERN, [1], [Must declare 'environ' to use it.])
+        has_environ=yes
+      ], [
+        has_environ=no
+      ])
+    AC_MSG_RESULT([${has_environ}])
+  ])
+
+AS_IF([test "x${has_environ}" != "xyes" ], [
+  AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.])
+])
+
+AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])
+
+# set default gcc warnings
+GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security -Wshadow"
+AS_IF([test "x${gcc_wextra}" = "xyes"], [
+  GCC_WARNINGS="${GCC_WARNINGS} -Wextra -Wno-unused-parameter"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wbad-function-cast"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wcast-align"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wredundant-decls"
+])
+AS_IF([test "x${gcc_werror}" = "xyes"], [
+  GCC_WARNINGS="${GCC_WARNINGS} -Werror"
+])
+
+# overide default gcc cflags
+AS_IF([test "x$gcc_warnings" = "xyes"], [
+  AC_SUBST([GCC_WARNINGS], [$GCC_WARNINGS])
+])
+
+AC_CONFIG_FILES([
+  Makefile
+])
+AC_OUTPUT
+
+echo
+echo
+echo OpenOCD configuration summary
+echo --------------------------------------------------
+m4_foreach([adapter], [USB1_ADAPTERS, USB_ADAPTERS, USB0_ADAPTERS,
+	HIDAPI_ADAPTERS, HIDAPI_USB1_ADAPTERS, LIBFTDI_ADAPTERS,
+	LIBJAYLINK_ADAPTERS],
+	[s=m4_format(["%-40s"], ADAPTER_DESC([adapter]))
+	AS_CASE([$ADAPTER_VAR([adapter])],
+		[auto], [
+			echo "$s"yes '(auto)'
+		],
+		[yes], [
+			echo "$s"yes
+		],
+		[no], [
+			echo "$s"no
+	])
+])
+echo
+
+AS_IF([test "x$build_oocd_trace" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-oocd_trace)'
+  echo 'The oocd_trace driver is deprecated and will be removed in the next release.'
+  echo 'If you regularly use this driver, please report to the OpenOCD Mailing List.'
+  echo
+])
+
+AS_IF([test "x$build_zy1000" = "xyes" -o "x$build_zy1000_master" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-zy1000, --enable-zy1000-master)'
+  echo 'Support for the ZY1000 platform is deprecated and will be removed in the next'
+  echo 'release. If you regularly use this platform, please report to the OpenOCD'
+  echo 'Mailing List.'
+  echo
+])
+
+AS_IF([test "x$build_ioutil" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-ioutil)'
+  echo 'Support for the ioutil functions is deprecated and will be removed in the next'
+  echo 'release. If you regularly depend on this functionality, please report to the'
+  echo 'OpenOCD Mailing List.'
+  echo
+])
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 6fe40a6..7275019 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,185 +1,189 @@
-noinst_LTLIBRARIES += %D%/libocdjtagdrivers.la
-%C%_libocdjtagdrivers_la_LIBADD =
-
-%C%_libocdjtagdrivers_la_SOURCES = \
-	$(DRIVERFILES) \
-	$(DRIVERHEADERS)
-
-%C%_libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS)
-
-ULINK_FIRMWARE = %D%/OpenULINK
-
-EXTRA_DIST += $(ULINK_FIRMWARE) \
-	%D%/usb_blaster/README.CheapClone \
-	%D%/Makefile.rlink \
-	%D%/rlink_call.m4 \
-	%D%/rlink_init.m4
-
-DRIVERFILES =
-
-# Standard Driver: common files
-DRIVERFILES += %D%/driver.c
-
-if USE_LIBUSB1
-DRIVERFILES += %D%/libusb1_common.c
-%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB1_CFLAGS)
-%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB1_LIBS)
-endif
-
-if USE_LIBUSB0
-DRIVERFILES += %D%/usb_common.c
-%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB0_CFLAGS)
-%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB0_LIBS)
-if !USE_LIBUSB1
-DRIVERFILES += %D%/libusb0_common.c
-endif
-endif
-
-if USE_LIBFTDI
-%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBFTDI_CFLAGS)
-%C%_libocdjtagdrivers_la_LIBADD += $(LIBFTDI_LIBS)
-endif
-
-if USE_HIDAPI
-%C%_libocdjtagdrivers_la_CPPFLAGS += $(HIDAPI_CFLAGS)
-%C%_libocdjtagdrivers_la_LIBADD += $(HIDAPI_LIBS)
-endif
-
-if USE_LIBJAYLINK
-%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBJAYLINK_CFLAGS)
-%C%_libocdjtagdrivers_la_LIBADD += $(LIBJAYLINK_LIBS)
-endif
-
-if JLINK
-DRIVERFILES += %D%/jlink.c
-if INTERNAL_LIBJAYLINK
-SUBDIRS += %D%/libjaylink
-DIST_SUBDIRS += %D%/libjaylink
-
-%C%_libocdjtagdrivers_la_LIBADD += %D%/libjaylink/libjaylink/libjaylink.la
-%C%_libocdjtagdrivers_la_CPPFLAGS += -I$(builddir)/%D%/libjaylink/libjaylink -I$(srcdir)/%D%/libjaylink
-endif
-endif
-
-if BITBANG
-DRIVERFILES += %D%/bitbang.c
-endif
-if PARPORT
-DRIVERFILES += %D%/parport.c
-endif
-if DUMMY
-DRIVERFILES += %D%/dummy.c
-endif
-DRIVERFILES += %D%/jtag_tcp.c
-if FTDI
-DRIVERFILES += %D%/ftdi.c %D%/mpsse.c
-endif
-if JTAG_VPI
-DRIVERFILES += %D%/jtag_vpi.c
-endif
-if USB_BLASTER_DRIVER
-%C%_libocdjtagdrivers_la_LIBADD += %D%/usb_blaster/libocdusbblaster.la
-include %D%/usb_blaster/Makefile.am
-endif
-if FT232R
-DRIVERFILES += %D%/ft232r.c
-endif
-if AMTJTAGACCEL
-DRIVERFILES += %D%/amt_jtagaccel.c
-endif
-if EP93XX
-DRIVERFILES += %D%/ep93xx.c
-endif
-if AT91RM9200
-DRIVERFILES += %D%/at91rm9200.c
-endif
-if GW16012
-DRIVERFILES += %D%/gw16012.c
-endif
-if BITQ
-DRIVERFILES += %D%/bitq.c
-endif
-if PRESTO
-DRIVERFILES += %D%/presto.c
-endif
-if USBPROG
-DRIVERFILES += %D%/usbprog.c
-endif
-if RLINK
-DRIVERFILES += %D%/rlink.c %D%/rlink_speed_table.c
-endif
-if ULINK
-DRIVERFILES += %D%/ulink.c
-ulinkdir = $(pkgdatadir)/OpenULINK
-dist_ulink_DATA = $(ULINK_FIRMWARE)/ulink_firmware.hex
-%C%_libocdjtagdrivers_la_LIBADD += -lm
-endif
-if VSLLINK
-DRIVERFILES += %D%/versaloon/usbtoxxx/usbtogpio.c
-DRIVERFILES += %D%/versaloon/usbtoxxx/usbtojtagraw.c
-DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoswd.c
-DRIVERFILES += %D%/versaloon/usbtoxxx/usbtopwr.c
-DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoxxx.c
-DRIVERFILES += %D%/versaloon/versaloon.c
-DRIVERFILES += %D%/vsllink.c
-endif
-if ARMJTAGEW
-DRIVERFILES += %D%/arm-jtag-ew.c
-endif
-if BUSPIRATE
-DRIVERFILES += %D%/buspirate.c
-endif
-if REMOTE_BITBANG
-DRIVERFILES += %D%/remote_bitbang.c
-endif
-if HLADAPTER
-DRIVERFILES += %D%/stlink_usb.c
-DRIVERFILES += %D%/ti_icdi_usb.c
-endif
-if OSBDM
-DRIVERFILES += %D%/osbdm.c
-endif
-if OPENDOUS
-DRIVERFILES += %D%/opendous.c
-endif
-if SYSFSGPIO
-DRIVERFILES += %D%/sysfsgpio.c
-endif
-if BCM2835GPIO
-DRIVERFILES += %D%/bcm2835gpio.c
-endif
-if OPENJTAG
-DRIVERFILES += %D%/openjtag.c
-endif
-if CMSIS_DAP
-DRIVERFILES += %D%/cmsis_dap_usb.c
-endif
-if IMX_GPIO
-DRIVERFILES += %D%/imx_gpio.c
-endif
-if KITPROG
-DRIVERFILES += %D%/kitprog.c
-endif
-if XDS110
-DRIVERFILES += %D%/xds110.c
-endif
-
-DRIVERHEADERS = \
-	%D%/bitbang.h \
-	%D%/bitq.h \
-	%D%/libusb0_common.h \
-	%D%/libusb1_common.h \
-	%D%/libusb_common.h \
-	%D%/minidriver_imp.h \
-	%D%/mpsse.h \
-	%D%/rlink.h \
-	%D%/rlink_dtc_cmd.h \
-	%D%/rlink_ep1_cmd.h \
-	%D%/rlink_st7.h \
-	%D%/usb_common.h \
-	%D%/versaloon/usbtoxxx/usbtoxxx.h \
-	%D%/versaloon/usbtoxxx/usbtoxxx_internal.h \
-	%D%/versaloon/versaloon.h \
-	%D%/versaloon/versaloon_include.h \
-	%D%/versaloon/versaloon_internal.h
-
+noinst_LTLIBRARIES += %D%/libocdjtagdrivers.la
+%C%_libocdjtagdrivers_la_LIBADD =
+
+%C%_libocdjtagdrivers_la_SOURCES = \
+	$(DRIVERFILES) \
+	$(DRIVERHEADERS)
+
+%C%_libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS)
+
+ULINK_FIRMWARE = %D%/OpenULINK
+
+EXTRA_DIST += $(ULINK_FIRMWARE) \
+	%D%/usb_blaster/README.CheapClone \
+	%D%/Makefile.rlink \
+	%D%/rlink_call.m4 \
+	%D%/rlink_init.m4
+
+DRIVERFILES =
+
+# Standard Driver: common files
+DRIVERFILES += %D%/driver.c
+
+if USE_LIBUSB1
+DRIVERFILES += %D%/libusb1_common.c
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB1_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB1_LIBS)
+endif
+
+if USE_LIBUSB0
+DRIVERFILES += %D%/usb_common.c
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB0_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB0_LIBS)
+if !USE_LIBUSB1
+DRIVERFILES += %D%/libusb0_common.c
+endif
+endif
+
+if USE_LIBFTDI
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBFTDI_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBFTDI_LIBS)
+endif
+
+if USE_HIDAPI
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(HIDAPI_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(HIDAPI_LIBS)
+endif
+
+if USE_LIBJAYLINK
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBJAYLINK_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBJAYLINK_LIBS)
+endif
+
+if JLINK
+DRIVERFILES += %D%/jlink.c
+if INTERNAL_LIBJAYLINK
+SUBDIRS += %D%/libjaylink
+DIST_SUBDIRS += %D%/libjaylink
+
+%C%_libocdjtagdrivers_la_LIBADD += %D%/libjaylink/libjaylink/libjaylink.la
+%C%_libocdjtagdrivers_la_CPPFLAGS += -I$(builddir)/%D%/libjaylink/libjaylink -I$(srcdir)/%D%/libjaylink
+endif
+endif
+
+if BITBANG
+DRIVERFILES += %D%/bitbang.c
+endif
+if PARPORT
+DRIVERFILES += %D%/parport.c
+endif
+if DUMMY
+DRIVERFILES += %D%/dummy.c
+endif
+DRIVERFILES += %D%/jtag_tcp.c
+if FTDI
+DRIVERFILES += %D%/ftdi.c %D%/mpsse.c
+endif
+if JTAG_VPI
+DRIVERFILES += %D%/jtag_vpi.c
+endif
+if USB_BLASTER_DRIVER
+%C%_libocdjtagdrivers_la_LIBADD += %D%/usb_blaster/libocdusbblaster.la
+include %D%/usb_blaster/Makefile.am
+endif
+if LSCC_USB_CABLESERVER
+%C%_libocdjtagdrivers_la_LIBADD += %D%/lattice_usb_cableserver/liblsccusbcableserver.la
+include %D%/lattice_usb_cableserver/Makefile.am
+endif
+if FT232R
+DRIVERFILES += %D%/ft232r.c
+endif
+if AMTJTAGACCEL
+DRIVERFILES += %D%/amt_jtagaccel.c
+endif
+if EP93XX
+DRIVERFILES += %D%/ep93xx.c
+endif
+if AT91RM9200
+DRIVERFILES += %D%/at91rm9200.c
+endif
+if GW16012
+DRIVERFILES += %D%/gw16012.c
+endif
+if BITQ
+DRIVERFILES += %D%/bitq.c
+endif
+if PRESTO
+DRIVERFILES += %D%/presto.c
+endif
+if USBPROG
+DRIVERFILES += %D%/usbprog.c
+endif
+if RLINK
+DRIVERFILES += %D%/rlink.c %D%/rlink_speed_table.c
+endif
+if ULINK
+DRIVERFILES += %D%/ulink.c
+ulinkdir = $(pkgdatadir)/OpenULINK
+dist_ulink_DATA = $(ULINK_FIRMWARE)/ulink_firmware.hex
+%C%_libocdjtagdrivers_la_LIBADD += -lm
+endif
+if VSLLINK
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtogpio.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtojtagraw.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoswd.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtopwr.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoxxx.c
+DRIVERFILES += %D%/versaloon/versaloon.c
+DRIVERFILES += %D%/vsllink.c
+endif
+if ARMJTAGEW
+DRIVERFILES += %D%/arm-jtag-ew.c
+endif
+if BUSPIRATE
+DRIVERFILES += %D%/buspirate.c
+endif
+if REMOTE_BITBANG
+DRIVERFILES += %D%/remote_bitbang.c
+endif
+if HLADAPTER
+DRIVERFILES += %D%/stlink_usb.c
+DRIVERFILES += %D%/ti_icdi_usb.c
+endif
+if OSBDM
+DRIVERFILES += %D%/osbdm.c
+endif
+if OPENDOUS
+DRIVERFILES += %D%/opendous.c
+endif
+if SYSFSGPIO
+DRIVERFILES += %D%/sysfsgpio.c
+endif
+if BCM2835GPIO
+DRIVERFILES += %D%/bcm2835gpio.c
+endif
+if OPENJTAG
+DRIVERFILES += %D%/openjtag.c
+endif
+if CMSIS_DAP
+DRIVERFILES += %D%/cmsis_dap_usb.c
+endif
+if IMX_GPIO
+DRIVERFILES += %D%/imx_gpio.c
+endif
+if KITPROG
+DRIVERFILES += %D%/kitprog.c
+endif
+if XDS110
+DRIVERFILES += %D%/xds110.c
+endif
+
+DRIVERHEADERS = \
+	%D%/bitbang.h \
+	%D%/bitq.h \
+	%D%/libusb0_common.h \
+	%D%/libusb1_common.h \
+	%D%/libusb_common.h \
+	%D%/minidriver_imp.h \
+	%D%/mpsse.h \
+	%D%/rlink.h \
+	%D%/rlink_dtc_cmd.h \
+	%D%/rlink_ep1_cmd.h \
+	%D%/rlink_st7.h \
+	%D%/usb_common.h \
+	%D%/versaloon/usbtoxxx/usbtoxxx.h \
+	%D%/versaloon/usbtoxxx/usbtoxxx_internal.h \
+	%D%/versaloon/versaloon.h \
+	%D%/versaloon/versaloon_include.h \
+	%D%/versaloon/versaloon_internal.h
+
diff --git a/src/jtag/drivers/jtag_tcp.c b/src/jtag/drivers/jtag_tcp.c
index 5146d1b..24367e7 100644
--- a/src/jtag/drivers/jtag_tcp.c
+++ b/src/jtag/drivers/jtag_tcp.c
@@ -24,14 +24,18 @@
 
 #include <jtag/interface.h>
 #include <stdio.h>
+#ifdef _WIN32
+#include <winsock2.h>
+#else
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include <string.h>
 #include <arpa/inet.h>
-#include <fcntl.h>
 #include <sys/ioctl.h>
-#include "hello.h"
 #include <netinet/tcp.h>
+#endif
+#include <string.h>
+#include <fcntl.h>
+#include "hello.h"
 
 /* my private tap controller state, which tracks state for calling code */
 static tap_state_t jtag_tcp_state;
diff --git a/src/jtag/drivers/lattice_usb_cableserver/LatticeClient.h b/src/jtag/drivers/lattice_usb_cableserver/LatticeClient.h
new file mode 100644
index 0000000..6ff9762
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/LatticeClient.h
@@ -0,0 +1,293 @@
+#ifndef LATTICE_CLIENT
+#define LATTICE_CLIENT
+#ifdef _WINDOWS
+#ifdef CABLECLIENT_EXPORTS
+#define CABLECLIENT_API __declspec(dllexport)
+#else
+#define CABLECLIENT_API __declspec(dllimport)
+#endif
+#else
+#define CABLECLIENT_API
+#endif
+#define D_QueryCable 1 // tested
+#define D_QueryCablePort 2 // tested
+#define D_CheckCable 3 // tested
+#define D_SetCablePort 4 // tested
+#define D_SetTRSTOption 5 // tested
+#define D_GetTRSTOption 6 // tested
+#define D_SetTCKDelay 7 // tested
+#define D_GetTCKDelay 8 // tested
+#define D_SetISPENOption 9 // tested
+#define D_GetISPENOption 10 // tested
+#define D_ScanDeviceChain 11 // need to work on this
+#define D_LoadXCFFile 12 // need to work on this
+#define D_GetDeviceCount 13 // tested
+#define D_GetDeviceList 14 // tested
+#define D_SetTargetDevice 15 // tested
+#define D_GetDeviceID 16 // tested
+#define D_GetDeviceDataFile 17 // tested
+#define D_JumpState 18 // tested
+#define D_Shift 19 // tested
+#define D_ENDState 20 // tested
+#define D_SetHeaderTrailer 21 // tested
+#define D_ResetHeaderTrailer 22 // tested
+#define D_SetAvoidTLRState 23 // tested
+#define D_SetCSHigh 24
+#define D_SetCSLow 25
+#define D_I2CStart 26
+#define D_I2CRestart 27
+#define D_I2CStop 28
+#define D_SetLogFile 29 // tested
+#define D_GetLogfile 30
+#define D_SetDebugOn 31 // tested
+#define D_SetDebugOff 32
+#define D_LockCable 33 // tested
+#define D_UnlockCable 34 // tested
+#define D_ReleaseCablePort 35 // tested
+#define D_SetPin 36 // tested
+#define D_SetTCK 37 // tested
+#define D_ClockPulse 38 // tested
+#define D_SetDelay 39 // tested
+#define D_ShiftState 40 // tested
+#define D_SetSharableApplications 41
+#define D_PumpData 42 // tested
+#define D_GetServerStatus 43
+#define D_JTAGInterface 44
+#define D_SetI2CInterface 45
+#define D_I2CWrite 46
+#define D_I2CRead 47
+#define D_I2CWriteRead 48
+#define D_SetSSPIInterface 49
+#define D_SSPIWrite 50
+#define D_SSPIRead 51
+#define D_SSPIWriteRead 52
+#define D_IPSend 53
+#define D_GDBPort 54
+#define D_DownloadSize 55
+#define D_QueryCablewDescription 56
+
+#define D_fnExportDLLMessage 1
+#define D_SetLinuxParallelPort 2
+#define D_ReadLinuxParallelPort 3
+#define D_SetParallelPort2Write 4
+#define D_fnSetPin 5
+#define D_SetBit 6
+#define D_GetTDO 7
+#define D_GetTDOBit 8
+#define D_GetDONEBit 9
+#define D_GetINITBit 10
+#define D_GetCurrentStateStr 11
+#define D_jtagShiftData 12
+#define D_fnJumpState 13
+#define D_fnTClock 14
+#define D_fnTClockHigh 15
+#define D_fnTClockLow 16
+#define D_jtagSetTRST 17
+#define D_jtagSetTDI 18
+#define D_jtagSetTMS 19
+#define D_jtagSetTCK 20
+#define D_jtagSetTDO 21
+#define D_jtagSetCableEN 22
+#define D_jtagSetIspEN 23
+#define D_jtagSetPROG 24
+#define D_fnSetOS 25
+#define D_fnSetMixedChain 26
+#define D_boolIsMixedChain 27
+#define D_fnSetProtocol 28
+#define D_fnGetProtocol 29
+#define D_fnSetHDR 30
+#define D_fnSetHIR 31
+#define D_fnSetTDR 32
+#define D_fnSetTIR 33
+#define D_fnSetEndIR 34
+#define D_fnSetEndDR 35
+#define D_fnSetFrequency 36
+#define D_fnGetEndDR 37
+#define D_fnGetEndIR 38
+#define D_fnGetCurrentState 39
+#define D_fnGetHDR 40
+#define D_fnGetHIR 41
+#define D_fnGetTDR 42
+#define D_fnGetTIR 43
+#define D_fnGetFrequency 44
+#define D_fnSetOutputPort 45
+#define D_fnSetInputPort 46
+#define D_fnGetOutputPort 47
+#define D_fnGetInputPort 48
+#define D_fnSetContinueOnError 49
+#define D_IsContinueOnError 50
+#define D_fnSetLogFileName 51
+#define D_fnGetLogFileName 52
+#define D_fnSetOutputFileName 53
+#define D_fnGetOutputFileName 54
+#define D_fnSetDebugFileName 55
+#define D_fnGetDebugFileName 56
+#define D_fnSetDebugMode 57
+#define D_fnGetDebugMode 58
+#define D_fnGetCable 59
+#define D_fnSetCable 60
+#define D_fnGetErrorcode 61
+#define D_fnSetErrorcode 62
+#define D_fnSetCurrentState 63
+#define D_fnSetTCKDelay 64
+#define D_fnGetTCKDelay 65		
+#define D_fnSetBufferAcess 66
+#define D_fnSetInitialPin 67
+#define D_fnSetVantisPin 68
+#define D_fnDelay 69
+#define D_fnTestDelay 70
+#define D_RunTCK 71
+#define D_iscShiftData 72
+#define D_fnEnableStacking 73
+#define D_fnDisableStacking 74
+#define D_fnIsStacking 75
+#define D_outport 76
+#define D_inport 77
+#define D_fnReadRegInit 78
+#define D_fnIsReadRegInit 79
+#define D_fnResetRegisters 80
+#define D_fnSetPort 81
+#define D_fnReSetISPPin 82
+#define D_fnEnableUSBSupport 83
+#define D_fnSetUSBDriver 84
+#define D_fnGetUSBDriver 85
+#define D_fnSearchUSBDriver 86
+#define D_fnDisableUSBSupport 87
+#define D_fnGetUSBSupport 88
+#define D_fnUSBPumpData 89
+#define D_fnUSBNoReversePumpData 90
+#define D_fnUSBShiftState 91
+#define D_fnUSBShiftCommand 92
+#define D_fnSetispPin 93
+#define D_fnGetispPin 94
+#define D_fnSetLoop 95
+#define D_fnPrintNumberLoop 96
+#ifdef _WINDOWS											
+#define D_fnGetHandleUSB 99
+#endif
+#define D_fnGetUSBBufferIndex 100
+#define D_fnGetNTDriver 101
+#define D_fnSetNTDriver 102
+#define D_fnGetRowCount 103
+#define D_fnSetRowCount 104
+#define D_fnReadParallelPortRegInit 105
+#define D_fnSetReadRegInit 106
+#define D_fnCheckParallelPort 107
+#define D_fnCheckParallelPortDriver 108
+#define D_Shift_Test_Cable_Detect 109
+#define D_fnSetSlaveSPISupport 110
+#define D_fnGetSlaveSPISupport 111
+#define D_fnSearchFTUSBDriver 112
+#define D_fnGetFTUSBSupport 113
+#define D_fnSearchFTUSBLatticeCables 114
+#define D_fnEnableFTUSBLatticeCable 115
+#define D_fnIsFTUSBLatticeCable 116
+#define D_fnSetAvoidTLRState 117
+#define D_fnGetAvoidTLR 118
+#define D_fnSearchUSBCables 119
+#define D_SetListUSBCables 120
+#define D_fnGetListUSBCables 121
+#define D_fnSetUSBPhysicalPort 122
+#define D_fnGetUSBPhysicalPort 123
+#define D_fnCheckUSBDriver 124
+#define D_fnSearchParallelPorts 125
+#define D_fnGetListParallelPorts 126
+#define D_fnSetDisableCable 127
+#define D_fnIsCableEnable 128
+#define D_fnIsParallelCable 129
+#define D_fnJTAGShiftData8Bits 130
+#define D_fnTJTAGClock 131
+#define D_fnShiftState 132
+#define D_SetDisplayFunction 133
+#define D_fnSetI2CSupport 134
+#define D_fnGetI2CSupport 135
+#define D_fnSetI2CStart 136
+#define D_fnSetI2CReStart 137
+#define D_fnSetI2CStop 138
+#define D_dwGetCounter 139
+#define D_dwDiffCounter 140
+#define D_fnSetSilentMsg 141
+#define D_ShiftHeader 142
+#define D_ShiftTrailer 143
+
+////////////////////////////
+
+#define D_DISCONNECT 9999
+
+#define JTAG_INSTRUCTION_SDR 0x01
+#define JTAG_INSTRUCTION_SIR 0x00
+
+#define STATE_UNDEFINED 0
+#define jtagTEST_LOGIC_RESET 1
+#define jtagRUN_TEST_IDLE 2
+#define jtagPAUSEIR 3
+#define jtagPAUSEDR 4
+#define jtagSHIFTDR 5
+#define jtagSHIFTIR 6
+#define ispIDLE 7
+#define ispEXECUTE 8
+#define ispSHIFT 9
+#define jtagCAPTUREDR 10
+
+class msgManager; // new message manager class 
+class CABLECLIENT_API Client {
+private:
+   int m_intMutex;
+   int m_intMutex2;
+   int sendShiftargs(SOCKET ClientSocket, va_list a_List);
+   int sendJTAGShiftargs(SOCKET a_ClientSocket, va_list a_List);
+   int sendPumpData(SOCKET &ClientSocket, va_list a_List);
+   int sendSharedApps(SOCKET &a_ClientSocket, va_list a_List);
+   int JTAGInterfaceFunc(SOCKET &a_ClientSocket, va_list a_List);
+   int sendSSPIShiftargs(SOCKET &a_ClientSocket, int a_intWrite, int a_intRead, va_list a_List);
+   int sendI2CShiftargs(SOCKET &a_ClientSocket, int a_intWrite, int a_intRead, va_list a_List);
+   std::string m_strTdo;
+   msgManager* m_ClientMsgMgr;
+
+   std::string m_strClientName;
+   std::string m_strCableName;
+   std::string m_strPort;
+   SOCKET m_ClientSocket;
+   std::string m_strhostname;
+   int m_intClientStatus;
+   
+   int m_intDebugFlag;
+   std::string m_strDebugLogfileName;
+   std::string m_strDebugPath;
+   FILE* m_ptrFilePointer;
+   int m_intlogfileid;
+public:
+   // Default constructor dummy constructor
+   Client(); 
+
+   // Local constructor
+   Client(char* name);
+   
+   // Destructor
+   ~Client();
+
+   bool ValidClient();
+   int Connect(char* a_chrHostName, const char* a_chrFileName=0, const char*a_chrCableServerDir=0);
+   int Send(int a_intCmd, ...);
+   const char *Read();
+   int Read(char*& a_chrData);
+   int Read(int& a_intData);
+   int Read(std::vector<std::string> &a_strData);
+   int Disconnect();
+   int GetTDO(unsigned char* &a_chrTDO, int a_intClock);
+   //int GetTDO(char* &a_chrTDO, int a_intClock);
+   int GetTDO(char* a_chrTDO, int a_intClock);
+
+   // Debug Operations:
+   int Set_Log_File(const char* a_chrFileName);
+   int Get_Log_file();
+   int Set_Debug_On();
+   int Set_Debug_Off();
+   int GetClientStatus();
+   void SetClientStatus(int a_intStatus);
+   long int GetClientSocket();
+   void PrintMessage(std::string string_id, ...);
+   
+};
+
+#endif
\ No newline at end of file
diff --git a/src/jtag/drivers/lattice_usb_cableserver/LatticeClientUtil.h b/src/jtag/drivers/lattice_usb_cableserver/LatticeClientUtil.h
new file mode 100644
index 0000000..9cdb984
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/LatticeClientUtil.h
@@ -0,0 +1,58 @@
+// Utility Class for client
+
+#ifndef LATTICE_CLIENT_UTIL
+#define LATTICE_CLIENT_UTIL
+
+#ifndef _WINDOWS
+typedef int SOCKET;
+#define INVALID_SOCKET -1
+#define SOCKET_ERROR   -1
+#endif
+#include "LByteBuffer.h"
+#include "LEnumeratedTypeDecl.h"
+
+#define PORT                            "4001"
+#define SERVER_PORT                     4001
+#define MAX_PACKET_LENGTH               1024
+#define ACK "+\0"
+
+
+const unsigned char g_ucPinTDI      = 0x01;    /* Bit address of TDI signal */
+const unsigned char g_ucPinTCK      = 0x02;    /* Bit address of TCK signal */
+const unsigned char g_ucPinTMS      = 0x04;    /* Bit address of TMS signal */
+const unsigned char g_ucPinENABLE   = 0x08;    /* Bit address of chip enable */
+const unsigned char g_ucPinTRST     = 0x10;    /* Bit address of TRST signal */
+const unsigned char g_ucPinCE       = 0x20;    /* Bit address of buffer chip enable */
+const unsigned char g_ucPinTDO      = 0x40;    /* Bit address of TDO signal */
+class msgManager;
+class ClientUtils{
+public:
+   msgManager* m_ClientUtilMsgMgr;
+   std::string m_strClientName;
+   std::string m_strDebugLogfileName;
+   int m_intDebugFlag;
+   FILE* m_ptrFilePointer;
+   
+   ClientUtils();
+
+   ClientUtils(int a_intFlag, FILE* a_ptrFp, std::string a_strClient, std::string a_strfilename);
+
+   ~ClientUtils();
+
+   int sendstrargs(SOCKET a_ClientSocket, int a_intLoopCount, va_list a_List);
+   int sendintargs(SOCKET a_ClientSocket, int a_intLoopCount, va_list a_List);
+   int sendcharstarargs(SOCKET a_ClientSocket, int a_intLoopCount, va_list a_List);
+   int sendSetHeaderTrailerargs(SOCKET a_ClientSocket, va_list a_List);
+   int sendStartargs(SOCKET a_ClientSocket, va_list a_List); // Implement in a later version
+   int DebugPrintProcessIDandName(DWORD a_dwProcessID);
+   int DetectServer(void);
+   int DetermineMutex(SOCKET &a_ClientSocket, int& a_intClientMutex);
+   int RecieveMutexInfo(SOCKET &a_ClientSocket, int& a_intClientMutex);
+   int sendArrayarg(SOCKET &a_ClientSocket, std::vector<std::string> array);
+   void PrintMessage(std::string string_id, ...);
+
+};
+
+int SendJTAGShiftData(SOCKET &a_ClientSocket, int instruction, int bit_length, int num_arg, LByteBuffer TDI, LByteBuffer TDO, LByteBuffer Mask);
+
+#endif
\ No newline at end of file
diff --git a/src/jtag/drivers/lattice_usb_cableserver/Makefile.am b/src/jtag/drivers/lattice_usb_cableserver/Makefile.am
new file mode 100644
index 0000000..772c25e
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES += %D%/liblsccusbcableserver.la
+%C%_liblsccusbcableserver_la_SOURCES = $(USB_CABLESERVER_SRC)
+%C%_liblsccusbcableserver_la_CPPFLAGS = -I$(top_srcdir)/src/jtag/drivers $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS) $(LIBFTDI_CFLAGS)
+
+USB_CABLESERVER_SRC = %D%/lattice_usb_cableserverclient.c %D%/lscc_cableserver_client.h
+
+if LSCC_USB_CABLESERVER
+USB_CABLESERVER_SRC += %D%/lattice_usb_cableserverclient.c
+endif
+
+liblsccusbcableserver_la_LIBADD = %D%/cableserver_client.lib
diff --git a/src/jtag/drivers/lattice_usb_cableserver/a.h b/src/jtag/drivers/lattice_usb_cableserver/a.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/jtag/drivers/lattice_usb_cableserver/cableserver_client.dll b/src/jtag/drivers/lattice_usb_cableserver/cableserver_client.dll
new file mode 100644
index 0000000000000000000000000000000000000000..6391a001e553a0d55de08ac2200f9c9ee057ac62
GIT binary patch
literal 79360
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
Pfw2MPd>Z}_x4{1bN{-YU

literal 0
HcmV?d00001

diff --git a/src/jtag/drivers/lattice_usb_cableserver/cableserver_client.lib b/src/jtag/drivers/lattice_usb_cableserver/cableserver_client.lib
new file mode 100644
index 0000000000000000000000000000000000000000..1c02d756289cfe8e773f99f2ab6e2c1e13630d9b
GIT binary patch
literal 12944
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
RBk-$`m~|!E*C~=d{trn7!_xo&

literal 0
HcmV?d00001

diff --git a/src/jtag/drivers/lattice_usb_cableserver/cableserverclient.xml b/src/jtag/drivers/lattice_usb_cableserver/cableserverclient.xml
new file mode 100644
index 0000000..73d32c7
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/cableserverclient.xml
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<messageFile stamp="20150313" vendor="Lattice Semiconductor Corporation" alias="csc" fid="8503" name="cableserverclient">
+  <description text="this message file contains message for cableserver message"/>
+  <owner text="Michael"/>
+  <!-- owner of this message file .-->
+  <messages>
+    <!-- LatticeClient.cpp-->
+    <msg text="Hostname: $$s\n" type="Error" uid="999"/>
+    <msg text="$$s: WSAStartup failed with error: $$d\n$$s: Errorcode: -1003 Socket creation has failed." type="Error" uid="1000"/>
+    <msg text="$$s: Launching Lattice Server" type="Info" uid="1001"/>
+    <msg text="$$s: Cable Server is already running or is running remote" type="Info" uid="1002"/>
+    <msg text="$$s: getaddrinfo failed with error: $$d\n$$s: Errorcode: -1004 Failed to get address information for client." type="Error" uid="1003"/>
+    <msg text="$$s: socket failed with error: INVALID_SOCKET\n$$s: Errorcode: -1003 Socket creation has failed." type="Error" uid="1004"/>
+    <msg text="$$s: Unable to connect to server!\n$$s: Errorcode: -1005 Failed to connect to server." type="Error" uid="1005"/>
+    <msg text="$$s: send failed during Connect()\n$$s: Errorcode: -1001 Lost connection on send." type="Error" uid="1006"/>
+    <msg text="$$s: send failed during Connect()\n$$s: Errorcode: -1002 Lost connection on recieve." type="Error" uid="1007"/>
+    <msg text="$$s: Cannot preform this operation $$s do not have a cable m_intMutex!" type="Error" uid="1008"/>
+    <msg text="$$s: Send(int a_intCmd, ...) send failed\n$$s: Errorcode -1001 Lost connection on send." type="Error" uid="1009"/>
+    <msg text="$$s: Send(int a_intCmd, ...) recv failed\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1010"/>
+    <msg text="$$s: client name = $$s and m_intMutex = $$d" type="Info" uid="1011"/>
+    <msg text="$$s: Client is freeing m_intMutex.  Mutex = $$d" type="Info" uid="1012"/>
+    <msg text="$$s: ERROR could not determine command." type="Error" uid="1013"/>
+    <msg text="$$s: Read(string) send failed\n$$s: Errorcode -1001 Lost connection on send." type="Error" uid="1014"/>
+    <msg text="$$s: Read(string) send data $$s" type="Info" uid="1015"/>
+    <msg text="$$s: Read(string) recv failed\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1016"/>
+    <msg text="$$s: Read(string) recv data $$s" type="Info" uid="1017"/>
+    <msg text="$$s: Read(int) send failed\n$$s: Errorcode -1001 Lost connection on send." type="Error" uid="1018"/>
+    <msg text="$$s: Read(int) send data $$s" type="Info" uid="1019"/>
+    <msg text="$$s: Read(int) recv failed\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1020"/>
+    <msg text="$$s: Read(int) recv data $$s" type="Info" uid="1021"/>
+    <msg text="$$s: Read(string) send failed\n$$s: Errorcode -1001 Lost connection on send." type="Error" uid="1022"/>
+    <msg text="$$s: Read(string) send data $$s" type="Info" uid="1023"/>
+    <msg text="$$s: Read(string) recv failed\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1024"/>
+    <msg text="$$s: Read(string) recv data $$s" type="Info" uid="1025"/>
+    <msg text="$$s: failed to send Disonnect to Server.\n$$s: Errorcode -1008 Client failed to send disconnect command to server" type="Error" uid="1026"/>
+    <msg text="$$s: shutdown failed with error: SOCKET_ERROR" type="Error" uid="1027"/>
+    <msg text="$$s: Connection Closed" type="Info" uid="1028"/>
+    <msg text="$$s: filename is NULL.  Please provide a filename." type="Error" uid="1029"/>
+    <msg text="$$s: path is NULL.  Please provide path to the logfile." type="Error" uid="1030"/>
+    <msg text="$$s: m_ptrFilePointer is NULL." type="Error" uid="1031"/>
+    <msg text="$$s: Filename is NULL.  Filename was not set." type="Error" uid="1032"/>
+    <msg text="$$s: Path is NULL.  Path was not set." type="Error" uid="1033"/>
+    <msg text="$$s: m_strDebugLogfileName = $$s\n$$s: m_strDebugPath = $$s" type="Info" uid="1034"/>
+    <msg text="$$s: m_intDebugFlag has already been set." type="Error" uid="1035"/>
+    <msg text="$$s: m_intDebugFlag is already off." type="Error" uid="1036"/>
+    <msg text="$$s: send failed sendShiftargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1037"/>
+    <msg text="$$s: recv failed sendShiftargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1038"/>
+    <msg text="$$s: send failed sendJTAGShiftargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1039"/>
+    <msg text="$$s: recv failed sendJTAGShiftargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1040"/>
+    <msg text="$$s: sendPumpData() send data $$s" type="Info" uid="1041"/>
+    <msg text="$$s: sendJTAGShiftargs() send data $$s" type="Info" uid="1042"/>
+    <msg text="$$s: send failed sendPumpData\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1043"/>
+    <msg text="$$s: sendPumpData() send data $$s" type="Info" uid="1044"/>
+    <msg text="$$s: recv failed sendPumpData\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1045"/>
+    <msg text="$$s: send failed sendSSPIShiftargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1046"/>
+    <msg text="$$s: sendSSPIShiftargs() send data $$s" type="Info" uid="1047"/>
+    <msg text="$$s: recv failed sendSSPIShiftargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1048"/>
+    <msg text="$$s: send failed sendI2CShiftargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1049"/>
+    <msg text="$$s: sendI2CShiftargs() send data $$s" type="Info" uid="1050"/>
+    <msg text="$$s: recv failed sendI2CShiftargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1051"/>
+    <msg text="$$s: recv failed sendPumpData\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1052"/>
+    <msg text="$$s: recv failed sendPumpData\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1053"/>
+    <msg text="$$s: send failed sendfloatargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1054"/>
+    <msg text="$$s: recv failed sendfloatargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1055"/>
+    <msg text="$$s: GetTDO returned $$x" type="Info" uid="1056"/>
+    <msg text="$$s: JTAGInterface: Invalid function name in JTAG Interface." type="Error" uid="2000"/>
+    <!-- LatticeClientUtil.cpp-->
+    <msg text="$$s: send failed sendstrargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1056"/>
+    <msg text="$$s: sendstrargs() send data $$s" type="Info" uid="1057"/>
+    <msg text="$$s: recv failed sendstrargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1058"/>
+    <msg text="$$s: sendstrargs() recv data $$s" type="Info" uid="1059"/>
+    <msg text="$$s: send failed sendintargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1060"/>
+    <msg text="$$s: sendintargs() send data $$s" type="Info" uid="1061"/>
+    <msg text="$$s: recv failed sendintargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1062"/>
+    <msg text="$$s: sendintargs() recv data $$s" type="Info" uid="1063"/>
+    <msg text="$$s: send failed sendcharstarargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1064"/>
+    <msg text="$$s: sendcharstarargs() send data $$s" type="Info" uid="1065"/>
+    <msg text="$$s: recv failed sendcharstarargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1066"/>
+    <msg text="$$s: sendcharstarargs() recv data $$s" type="Info" uid="1067"/>
+    <msg text="$$s: send failed sendSetHeaderTrailerargs\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1068"/>
+    <msg text="$$s: sendcharstarargs() send data $$s" type="Info" uid="1069"/>
+    <msg text="$$s: recv failed sendSetHeaderTrailerargs\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1070"/>
+    <msg text="$$s: sendcharstarargs() recv data $$s" type="Info" uid="1071"/>
+    <msg text="$$s: Found cableserver.exe!" type="Info" uid="1072"/>
+    <msg text="$$s: send failed RecieveMutexInfo\n$$s: Errorcode -1001  Lost connection on send." type="Error" uid="1073"/>
+    <msg text="$$s: recv failed RecieveMutexInfo\n$$s: Errorcode -1002 Lost connection on recieve." type="Error" uid="1074"/>
+    <msg text="$$s: mutex has been set to $$d." type="Info" uid="1075"/>
+    <msg text="$$s: Desired cable is already in use by another application or desired cable is not connected." type="Info" uid="1076"/>
+    <msg text="$$s: Entered sendstrargs()" type="Info" uid="1077"/>
+    <msg text="$$s: sendstrargs returned 0." type="Info" uid="1078"/>
+    <msg text="$$s: Entered sendintargs()" type="Info" uid="1079"/>
+    <msg text="$$s: sendintargs returned 0." type="Info" uid="1080"/>
+    <msg text="$$s: Entered sendcharstarargs()" type="Info" uid="1081"/>
+    <msg text="$$s: sendcharstarargs returned 0." type="Info" uid="1082"/>
+    <msg text="$$s: Entered sendSetHeaderTrailerargs()" type="Info" uid="1083"/>
+    <msg text="$$s: sendSetHeaderTrailerargsreturned 0." type="Info" uid="1084"/>
+    <msg text="$$s: Attempting to detect the cableserver." type="Info" uid="1085"/>
+    <msg text="$$s: Entered Determine Mutex function" type="Info" uid="1086"/>
+<!-- LatticeClient.cpp-->
+    <msg text="$$s: Client is not Valid." type="Info" uid="1087"/>
+    <msg text="$$s: Client is Valid." type="Info" uid="1088"/>
+    <msg text="$$s: Attempting to Connect to the Server." type="Info" uid="1089"/>
+    <msg text="$$s: Attempting to get address information for socket" type="Info" uid="1090"/>
+    <msg text="$$s: Calling connect function" type="Info" uid="1091"/>
+    <msg text="$$s: Setting logfile in the connect function" type="Info" uid="1092"/>
+    <msg text="$$s: Client sending command $$d to server." type="Info" uid="1093"/>
+    <msg text="$$s: Client attempting to read data from server using Read(char*)." type="Info" uid="1094"/>
+    <msg text="$$s: Client attempting to read data from server using Read()." type="Info" uid="1095"/>
+    <msg text="$$s: Client attempting to read data from server using Read(int)." type="Info" uid="1096"/>
+    <msg text="$$s: Client attempting to read data from server using Read(vector string)." type="Info" uid="1097"/>
+    <msg text="$$s: Client disconnecting from server." type="Info" uid="1098"/>
+    <msg text="$$s: Setting client log file." type="Info" uid="1099"/>
+    <msg text="$$s: Client trying to turn debug on." type="Info" uid="1100"/>
+    <msg text="$$s: Client trying to turn debug off." type="Info" uid="1101"/>
+    <msg text="$$s: Sending arguments to Shift function" type="Info" uid="1102"/>
+    <msg text="$$s: Sending arguments to JTAGShift function" type="Info" uid="1103"/>
+    <msg text="$$s: Reading TDO from server" type="Info" uid="1104"/>
+    <msg text="$$s: TDO size is 0 function returned -1022" type="Info" uid="1105"/>
+    <msg text="$$s: connect about to call detect server function." type="Info" uid="1106"/>
+    <msg text="$$s: Creating Cable Server Process On Windows" type="Info" uid="1107"/>
+    <msg text="$$s: Creating Cable Server Process On Linux" type="Info" uid="1108"/>
+    <msg text="$$s: TDI in sendShiftargs = $$x" type="Info" uid="1109"/>
+    <msg text="$$s: Send Buffer = $$s" type="Info" uid="1110"/>
+    <msg text="$$s: TDI in sendJTAGShiftargs = $$x" type="Info" uid="1111"/>
+    <msg text="$$s: PumpData function" type="Info" uid="1112"/>
+    <msg text="$$s: sendSSPIShiftargs function" type="Info" uid="1113"/>
+    <msg text="$$s: sendI2CShiftargs function" type="Info" uid="1114"/>
+    <msg text="$$s: sendSharedApps function" type="Info" uid="1115"/>
+    <msg text="$$s: Client will shared with $$s" type="Info" uid="1116"/>
+    <msg text="$$s: Read Buffer = $$s" type="Info" uid="1117"/>
+    <msg text="" type="Error" uid="1118"/>
+    <msg text="" type="Error" uid="1119"/>
+    <msg text="" type="Error" uid="1120"/>
+    <msg text="" type="Error" uid="1121"/>
+    <msg text="" type="Error" uid="1122"/>
+    <msg text="" type="Error" uid="1123"/>
+  </messages>
+</messageFile>
diff --git a/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c b/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
new file mode 100644
index 0000000..f16bf7b
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
@@ -0,0 +1,2122 @@
+/*
+     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
+     ------------------------------------------------------------------
+     Copyright (c) 2019-2020 by Lattice Semiconductor Corporation
+     ------------------------------------------------------------------
+GNU General Public License & disclaimer:  This program is free software; you can 
+redistribute it and/or modify it under the terms of the GNU General Public License 
+as published by the Free Software Foundation; either version 2 of the License, or 
+(at your option) any later version.  This program is distributed in the hope that it 
+will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
+of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+General Public License for more details.  You may access the GNU General Public
+v2 License at https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+
+LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER 
+EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE 
+PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
+SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR 
+FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
+FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
+LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
+OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
+HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
+SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE 
+PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE 
+ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
+OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL ASSUME
+THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR ANY 
+OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
+SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT, 
+INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING 
+LOST PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN 
+IF LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
+LATTICE'S SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
+LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
+USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
+RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
+THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH
+THE USE OF FORMAL SOFTWARE VALIDATION METHODS.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include <usb.h>
+#include "helper/binarybuffer.h"
+#include "tlhelp32.h" 
+
+#define D_QueryCable 1
+#define D_QueryCablePort 2 
+#define D_CheckCable 3 
+#define D_SetCablePort 4 
+#define D_SetTCKDelay 7 // tested
+#define D_ScanDeviceChain 11 
+#define D_GetDeviceList 14 
+#define D_SetTargetDevice 15 
+#define D_GetDeviceID 16
+#define D_JumpState 18 
+#define D_Shift 19 
+#define D_ENDState 20
+#define D_LockCable 33 
+#define D_UnlockCable 34 
+#define D_ReleaseCablePort 35
+#define D_QueryCablewDescription 56
+#define D_DISCONNECT 9999
+
+#define jtagTEST_LOGIC_RESET 1
+#define jtagRUN_TEST_IDLE 2
+#define jtagPAUSEIR 3
+#define jtagPAUSEDR 4
+#define jtagSHIFTDR 5
+#define jtagSHIFTIR 6
+
+#define DAISY_CHAIN
+#define MAX_DEVICE_DAISY_CHAIN 10
+#define DC_TARGET_DEVICE 0  //daisy chain target device
+#define DC_DEV_NUM 3  //daisy chain device number
+
+#define ER2_SELECT_CHANNEL_CMD_LEN 3
+
+#define BUFFER_DEFINED
+
+#define WR_BUFF_HEADER_LASTBIT 0x08
+#define WR_BUFF_HEADER_TDR_HDR 0x04
+#define WR_BUFF_HEADER_READ 0x02
+#define WR_BUFF_HEADER_WRITE 0x01
+#define WR_BUFF_HEADER_NA 0x00
+
+#define MAX_BUFFER_SIZE (65535-1)
+
+#define DEV_NONE 0x00
+#define DEV_JEDI 0x01
+#define DEV_XO3D 0x02
+#define DEV_ECP5 0x04
+#define DEV_RAPTOR 0x08
+
+#define JTAG_ID_LEN 4
+#define DEV_FAMILY_NUM 3
+
+typedef int (*client_connect_func)(void* client_handler, char* a_chrHostName, const char* a_chrFileName, const char* a_chrCableServerDir);
+typedef void* (*client_create_func)(char *client_name);
+typedef int (*client_send_func)(void* client_handler, int a_intCmd, ...);
+typedef int (*client_read_func)(void* client_handler,  char p_buffer[10][256],  unsigned int *dev_num);
+typedef int (*client_get_tdo_func)(void* client_handler, char* a_chrTDO, int a_intClock);
+typedef int (*client_get_tdo_unsigned_func)(void* client_handler, unsigned char* a_chrTDO, int a_intClock);
+
+
+enum ShiftModes
+{
+    SHI_IR = 0,
+    SHI_DR = 1
+};
+
+enum TdoModes
+{
+    TDO_NO = 0,
+    TDO_YES = 1
+};
+
+struct daisy_chain_device_ctx{
+	unsigned int num;  							
+	unsigned int target; 
+	unsigned int trailer_len;
+	unsigned int header_len;
+	unsigned int TIR_len;
+	unsigned char *TIR_data;
+	unsigned int TDR_len;
+	unsigned char *TDR_data;
+	unsigned int HIR_len;
+	unsigned char* HIR_data;
+	unsigned int HDR_len;
+	unsigned char* HDR_data;
+	char dev_list[MAX_DEVICE_DAISY_CHAIN][256];  	
+};
+
+struct cableserver_client_ctx{
+	void *handle;
+	client_connect_func connect;
+	client_create_func create;
+	client_send_func send;
+	client_read_func read;
+	client_get_tdo_func get_tdo;
+	client_get_tdo_unsigned_func get_tdo_u;
+	uint8_t *in_value;
+	unsigned char *write_buffer;
+	unsigned char *read_buffer;
+	unsigned write_size;
+	unsigned read_size;
+	unsigned write_count;
+	unsigned read_count;
+};
+
+static struct cableserver_client_ctx *cableserver_client_ctx;
+static struct daisy_chain_device_ctx *daisy_chain_ctx;
+char *lattice_cable="USB2";
+char *lattice_port="FTUSB-0";
+char *lattice_target_dev="0";
+char *lattice_tck_delay="7";
+char *lattice_channel="NA"; //jtag hub channel select for diffrent core
+
+char *lattice_host_name = "jtagadapter";
+
+char dev_family_config[DEV_FAMILY_NUM][4][100]={
+		//name, 			JTAG ID, 		config len, 	channel
+		{"ECP5", 			"113043", 	"21", 		"0" 	},
+		{"Certurs-NX", 	"0F1043", 	"24", 		"14"	},
+		{"XO3D", 		"2E3043", 	"21", 		"0" 	},
+};
+
+
+//#define debug_on
+
+#define BRIDGE_4_BIT_UNIT // SWWA for bridge, it does not support daisy chain, unvalid data will be blocked.
+//#define TAP_SWWA_1027 //2020/10/27 add this swwa, match with FTDI driver
+/***************************************************************************/
+static void flip_array(unsigned char* send_data, unsigned w_header_bitlen){
+	unsigned char tmp=0x00;
+	for (int k=0; k<((w_header_bitlen+1)/2)/2; k++){
+		tmp=send_data[k];
+		send_data[k]=send_data[(w_header_bitlen+1)/2-1-k];
+		send_data[(w_header_bitlen+1)/2-1-k]=tmp;
+	}
+}
+
+static void extract_bridge_data(unsigned char * p_array, unsigned int bit_len,   //4*bitlen
+		unsigned char* p_ret_array){
+	int i,j=0;
+	unsigned char tmp=0x00;
+	//fprintf(stderr, "p_array, bitlen=%d\n",bit_len/4);
+	//for (int s_i=0; s_i<(bit_len+7)/8; s_i++){
+	//	fprintf(stderr, " 0x%02x", p_array[s_i]);
+	//}
+	//fprintf(stderr, "\n");
+			
+	for (i=((bit_len+7)/8)/4-1, j=0; i>=0;i--,j++){
+		p_ret_array[i]=(p_array[j*4+0]&0x80)|((p_array[j*4+0]&0x08)<<3)
+			|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+			|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+			|((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3);
+	}
+
+	switch(bit_len%32){
+		case 0:
+			//covert 4Byte
+			tmp=(p_array[j*4+0]&0x80)|((p_array[j*4+0]&0x08)<<3)
+				|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+				|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+				|((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 4:
+			tmp|=(p_array[j*4+0]&0x08)>>3;
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 8:
+			tmp|=((p_array[j*4+0]&0x80)>>6)|((p_array[j*4+0]&0x08)>>3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 12:
+			tmp|=((p_array[j*4+1]&0x80)>>6)|((p_array[j*4+1]&0x08)>>3)
+				|((p_array[j*4+1]&0x08)>>1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 16:
+			tmp|=((p_array[j*4+1]&0x80)>>6)|((p_array[j*4+1]&0x08)>>3)
+				|((p_array[j*4+0]&0x80)>>4)|((p_array[j*4+0]&0x08)>>1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 20:
+			tmp|=((p_array[j*4+2]&0x80)>>6)|((p_array[j*4+2]&0x08)>>3)
+				|((p_array[j*4+1]&0x80)>>4)|((p_array[j*4+1]&0x08)>>1)
+				|(((p_array[j*4+0]&0x08))<<1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 24:
+			tmp|=((p_array[j*4+2]&0x80)>>6)|((p_array[j*4+2]&0x08)>>3)
+				|((p_array[j*4+1]&0x80)>>4)|((p_array[j*4+1]&0x08)>>1)
+				|((p_array[j*4+0]&0x80)>>2)|((p_array[j*4+0]&0x08)<<1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 28:
+			tmp|=((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3)
+				|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+				|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+				|((p_array[j*4+0]&0x08)<<3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		default:
+			break;
+		
+	}
+}
+#if 0
+unsigned add_header(unsigned char *send_data, unsigned bit_send_len){
+	unsigned trailer_len=daisy_chain_ctx->num-1-daisy_chain_ctx->target;
+	unsigned char *trailer_data=NULL;
+	trailer_data=calloc((trailer_len*4+7)/8,sizeof(unsigned char));
+	memset(trailer_data, 0x33, (trailer_len*4+7)/8);
+	bit_copy(send_data,  bit_send_len*4, trailer_data, 0, trailer_len*4);
+	free(trailer_data);
+	return bit_send_len+trailer_len;
+}
+
+unsigned add_trailer(unsigned char *send_data, unsigned bit_send_len){
+	unsigned header_len=daisy_chain_ctx->num-1-daisy_chain_ctx->target;
+	unsigned char header_data[MAX_BUFFER_SIZE]={0};
+	memset(header_data, 0x33, (header_len*4+7)/8);
+	bit_copy(header_data,  header_len*4, send_data, 0, bit_send_len*4);
+	memcpy(send_data, header_data, ((bit_send_len+header_len)*4+7)/8);
+	return (bit_send_len+header_len);
+}
+#endif
+//bit_len
+int set_header_trailer(int hdr_len, unsigned char* hdr_data, int hir_len, unsigned char* hir_data,
+	int tdr_len, unsigned char* tdr_data, int tir_len, unsigned char* tir_data){
+       daisy_chain_ctx->HDR_len=hdr_len;
+	daisy_chain_ctx->HIR_len=hir_len;
+	daisy_chain_ctx->TDR_len=tdr_len;
+	daisy_chain_ctx->TIR_len=tir_len;
+
+	if (NULL!=daisy_chain_ctx->HDR_data)
+		free(daisy_chain_ctx->HDR_data);
+	if (NULL!=daisy_chain_ctx->HIR_data)
+		free(daisy_chain_ctx->HIR_data);
+	if (NULL!=daisy_chain_ctx->TDR_data)
+		free(daisy_chain_ctx->TDR_data);
+	if(NULL!=daisy_chain_ctx->TIR_data)
+		free(daisy_chain_ctx->TIR_data);
+	if (hdr_len>0){
+		daisy_chain_ctx->HDR_data = calloc((hdr_len+7)/8, sizeof(unsigned char));
+		if (NULL==hdr_data){
+			fprintf(stderr, "ERR: input HDR data error\n");
+			return -1;
+		}else{
+			bit_copy(daisy_chain_ctx->HDR_data, 0, hdr_data, 0, hdr_len);
+		}
+	}
+
+	if (hir_len>0){
+		daisy_chain_ctx->HIR_data = calloc((hir_len+7)/8, sizeof(unsigned char));
+		if (NULL==hir_data){
+			fprintf(stderr, "ERR: input HIR data error\n");
+			return -1;
+		}else{
+			bit_copy(daisy_chain_ctx->HIR_data, 0, hir_data, 0, hir_len);
+		}
+	}
+	if (tdr_len>0){
+		daisy_chain_ctx->TDR_data = calloc((tdr_len+7)/8, sizeof(unsigned char));
+		if(NULL==tdr_data){
+			fprintf(stderr, "ERR: input TDR data error\n");
+			return -1;
+		}else{
+			bit_copy(daisy_chain_ctx->TDR_data, 0, tdr_data, 0, tdr_len);
+		}
+	}
+	if (tir_len>0){
+		daisy_chain_ctx->TIR_data = calloc((tir_len+7)/8, sizeof(unsigned char));
+		if(NULL==tir_data){
+			fprintf(stderr, "ERR: input TIR data error\n");
+			return -1;
+		}else{
+			bit_copy(daisy_chain_ctx->TIR_data, 0, tir_data, 0, tir_len);
+		}
+	}
+	return 0;
+	
+}
+
+ void reset_header_trailer(void){
+	daisy_chain_ctx->HDR_len=0;
+	daisy_chain_ctx->HIR_len=0;
+	daisy_chain_ctx->TDR_len=0;
+	daisy_chain_ctx->TIR_len=0;
+	free(daisy_chain_ctx->HDR_data);
+	free(daisy_chain_ctx->HIR_data);
+	free(daisy_chain_ctx->TDR_data);
+	free(daisy_chain_ctx->TIR_data);
+ }
+
+ //#include <stdio.h>
+  
+#define MSB        0x80
+#define LSB        0x01
+  extern int gdb_input_flag;
+//shift 1bit
+int bit_left_shift(unsigned char *str, int len){
+	int i;
+	
+	for(i = 1; i <= len; i++){
+		str[i-1] = str[i-1] << 1;
+
+		if(i < len && str[i] & MSB){
+			str[i-1] = str[i-1] | LSB;    
+		}    
+	}
+	return 0;
+}
+
+//shift 1 bit
+int bit_right_shift(unsigned char *str, int len){
+	int i;
+
+	for(i = len-1; i >= 0; i--){
+		str[i] = str[i] >> 1;
+
+		if(i > 0 && str[i-1] & LSB){
+			str[i] = str[i] | MSB;    
+		}    
+	}
+	return 0;    
+}
+#ifdef BRIDGE_4_BIT_UNIT
+void swwa_add_header_bit(unsigned char send_data[MAX_BUFFER_SIZE], 
+	unsigned int bit_len_to_send, unsigned char final_send_data_swwa[MAX_BUFFER_SIZE+1]){
+	unsigned int final_data_len=(bit_len_to_send*4+daisy_chain_ctx->header_len+7)/8;
+	unsigned int send_data_len=(bit_len_to_send*4+7)/8;
+	memset(final_send_data_swwa, 0, MAX_BUFFER_SIZE+1);
+
+	
+	bit_copy(final_send_data_swwa, (final_data_len-send_data_len)*8, send_data, 0, send_data_len*8);
+	if(gdb_input_flag==1){
+		fprintf(stderr, "before send(bit_len_to_send), daisy_chain_ctx->header_len=%d bit_len_to_send=%d\n",daisy_chain_ctx->header_len, bit_len_to_send);
+
+		fprintf(stderr, "before send(send_data), send_data_len=%d\n",send_data_len);
+		for (int s1_i=0; s1_i<send_data_len; s1_i++){
+			fprintf(stderr, " 0x%02x", send_data[s1_i]);
+		}
+		fprintf(stderr, "\n");
+		
+		
+		fprintf(stderr, "before send(final_send_data_swwa), final_data_len=%d\n",final_data_len);
+		for (int s1_i=0; s1_i<final_data_len; s1_i++){
+			fprintf(stderr, " 0x%02x", final_send_data_swwa[s1_i]);
+		}
+		fprintf(stderr, "\n");
+	}
+			
+}
+
+#endif
+#ifndef BRIDGE_4_BIT_UNIT
+
+//this is only a SWWA for trailer device, e.g.: xo3d+jedi, jedi is a bridge jtag. so this swwa actually support fix this issue
+static unsigned swwa_add_trailer_header_bit(unsigned char send_data[MAX_BUFFER_SIZE], 
+	unsigned int bit_len_to_send, unsigned char final_send_data[MAX_BUFFER_SIZE+256]){
+#ifdef BRIDGE_4_BIT_UNIT
+	//final_data_len =((bit_len_to_send+daisy_chain_ctx->header_len+daisy_chain_ctx->trailer_len)*4+7)/8;
+	//unsigned int send_data_len=(bit_len_to_send*4+7)/8;
+	unsigned int final_data_len=(bit_len_to_send*4+daisy_chain_ctx->header_len+7)/8;
+	unsigned int send_data_len=(bit_len_to_send*4+7)/8;
+	memset(final_send_data, 0, MAX_BUFFER_SIZE+256);
+
+	bit_copy(final_send_data, (final_data_len-send_data_len)*8, send_data, 0, send_data_len*8);
+		
+	return daisy_chain_ctx->header_len; //(daisy_chain_ctx->header_len+daisy_chain_ctx->trailer_len)*4;
+#else
+	//SWWA for bridge daisy chain, this is the limitation for bridge jtag. since bridge jtag is not a standard jtag
+	//add 3bit in header, add 1bit in trailer, 3bit +XO3D1bit combined 4 bit, shift into jedi, they are considered as unuseful bit.
+	//all trailer should be 0, add bits should be 0
+	unsigned int trailer_bit_len= daisy_chain_ctx->trailer_len;// (4-daisy_chain_ctx->header_len%4)%4;
+	//unsigned char *tmp_data;
+	unsigned int final_data_len=(bit_len_to_send*4+trailer_bit_len+daisy_chain_ctx->header_len+7)/8;
+	unsigned int send_data_len=(bit_len_to_send*4+7)/8;
+	memset(final_send_data, 0, MAX_BUFFER_SIZE+256);
+
+	//tmp_data=calloc(tmp_data_len, sizeof(unsigned char));
+	//step1: add header 3 bit. (suppose the trailer device number =1)
+	//tmp_data is dummy 0
+	//all bits should be zero, to make it disavailble in bridge.
+	#ifdef debug_on
+	fprintf(stderr, "%d trailer bit added\n", trailer_bit_len);
+	fprintf(stderr, "%d header bit added\n", daisy_chain_ctx->header_len);
+
+	//printf send_data
+	printf("debug::\n");
+	printf("final_data_len=%d, send_data_len=%d\n",final_data_len,send_data_len);
+	printf("des offset=%d, src offset=%d, len=%d\n",final_data_len*8-trailer_bit_len-bit_len_to_send*4, send_data_len*8-bit_len_to_send*4, bit_len_to_send*4);
+	#endif
+	memset(final_send_data, 0, MAX_BUFFER_SIZE+256);
+
+#if 1 //TBD:
+	//the max header bit should be 4, so the max num JTAG device in this chain is 4
+	//only keep send data valid, others bits should be set to 0
+
+	memset(final_send_data, 0x00,(MAX_BUFFER_SIZE+256)*sizeof(unsigned char));
+
+	//if ((bit_len_to_send*4)%8 != 0)
+	//	send_data[0]=send_data[0]&0x0F;
+
+	bit_copy(final_send_data, (final_data_len-send_data_len)*8, send_data, 0, send_data_len*8);
+
+#if 0
+	if (final_data_len==send_data_len)
+		bit_copy(final_send_data, 0, send_data, 0, send_data_len*8);
+	else
+		bit_copy(final_send_data, 8, send_data, 0, send_data_len*8);
+#endif
+	
+	
+	//for(int i=0; i<trailer_bit_len; i++){
+//		bit_left_shift(final_send_data, final_data_len);
+//	}
+	
+	//bit_copy(final_send_data, final_data_len*8-trailer_bit_len-bit_len_to_send*4, send_data, send_data_len*8-bit_len_to_send*4, bit_len_to_send*4);
+#else
+	
+	bit_copy(final_send_data, (final_data_len-send_data_len)*8, send_data, 0, send_data_len*8);
+
+	for(int i=0; i<trailer_bit_len; i++){
+		bit_left_shift(final_send_data, final_data_len);
+	}
+#endif
+	
+	//copy to send_data, for next sectionto use
+	//bit_copy(final_send_data, 0, tmp_data, 0, tmp_data_len*8);
+
+	//free(tmp_data);
+
+	return 0;// trailer_bit_len+daisy_chain_ctx->header_len;
+#endif
+}
+#endif
+static unsigned cableserver_buffer_read_space(void){
+	return cableserver_client_ctx->read_size - cableserver_client_ctx->read_count;
+}
+
+static unsigned cableserver_buffer_write_space(void){
+	/* Reserve one byte for SEND_IMMEDIATE */
+	return cableserver_client_ctx->write_size - cableserver_client_ctx->write_count - 1;
+}
+
+static void cableserver_buffer_write_byte(uint8_t data){
+	assert(cableserver_client_ctx->write_count < cableserver_client_ctx->write_size);
+	cableserver_client_ctx->write_buffer[cableserver_client_ctx->write_count++] = data;
+}
+#ifdef BRIDGE_4_BIT_UNIT
+unsigned char last_byte_swwa=0;
+unsigned char bit_last_flag=0;
+unsigned char ir_in_value=0;
+unsigned char cmd_dr_flag=0;
+unsigned char dr_flag=0;
+unsigned char dr_in_value=0;
+unsigned char last_byte_1020=0;  //10/20/2020
+#endif
+
+static int cableserver_buffer_flush(void){
+	uint8_t w_header_flag=0;
+	unsigned w_header_bitlen=0;
+
+	unsigned i=0;
+	unsigned char send_data[MAX_BUFFER_SIZE]={0};
+	#ifndef BRIDGE_4_BIT_UNIT
+	unsigned char final_send_data[MAX_BUFFER_SIZE+256]={0};
+	#endif
+	#ifdef BRIDGE_4_BIT_UNIT
+	unsigned char final_send_data_swwa[MAX_BUFFER_SIZE+1]={0};
+	#endif
+	unsigned char received_data[MAX_BUFFER_SIZE]={0};
+	unsigned char received_data_test[MAX_BUFFER_SIZE+1]={0};
+	bool get_tdo_done=false;
+	unsigned m=0;
+	unsigned last_byte_bit_offset=0;
+	unsigned bit_len_to_send=0;
+	//fprintf(stderr, "jtag flush\n");
+	while(i<cableserver_client_ctx->write_count){
+		w_header_flag=cableserver_client_ctx->write_buffer[i];
+		w_header_bitlen=cableserver_client_ctx->write_buffer[i+2];
+		w_header_bitlen=(w_header_bitlen<<8)&0xFF00;
+		w_header_bitlen|=cableserver_client_ctx->write_buffer[i+1];
+
+		if(w_header_bitlen==0)
+			break;
+		
+		if((w_header_flag&WR_BUFF_HEADER_WRITE)==WR_BUFF_HEADER_WRITE){	
+			if((w_header_flag&WR_BUFF_HEADER_READ)!=WR_BUFF_HEADER_READ){
+				bit_copy(&send_data[m], last_byte_bit_offset, &(cableserver_client_ctx->write_buffer[i+3]), 0, w_header_bitlen*4);
+				bit_len_to_send+=w_header_bitlen;
+				if ((bit_len_to_send%2)==1){
+					last_byte_bit_offset=4;
+					m=(bit_len_to_send+1)/2-1;
+				}else{
+					last_byte_bit_offset=0;
+					m=(bit_len_to_send+1)/2;
+				}
+				i+=(3+(w_header_bitlen+1)/2); 
+			}else{ //before read cmd, send the write cmd, if there are
+				if(bit_len_to_send>0){
+					flip_array(send_data, bit_len_to_send);
+#ifdef BRIDGE_4_BIT_UNIT
+				swwa_add_header_bit(send_data, bit_len_to_send, final_send_data_swwa);
+				cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4+daisy_chain_ctx->header_len, TDO_NO, final_send_data_swwa);
+				
+				memset(send_data, 0, MAX_BUFFER_SIZE);
+#else
+					//SWWA
+					unsigned added_bit_len=0;
+					#ifdef debug_on
+						fprintf(stderr, "before send(no GET tdo), bitlen=%d\n",bit_len_to_send);
+						for (int s1_i=0; s1_i<(bit_len_to_send*4+7)/8; s1_i++){
+							fprintf(stderr, " 0x%02x", send_data[s1_i]);
+						}
+						fprintf(stderr, "\n");
+					#endif
+
+					added_bit_len = swwa_add_trailer_header_bit(send_data, bit_len_to_send, final_send_data);
+					#ifdef debug_on
+						fprintf(stderr, "converted, before send(no GET tdo), bitlen=%d\n",bit_len_to_send+added_bit_len);
+						for (int s_i=0; s_i<(bit_len_to_send*4+added_bit_len+7)/8; s_i++){
+							fprintf(stderr, " 0x%02x", final_send_data[s_i]);
+						}
+						fprintf(stderr, "\n");
+					#endif
+
+					cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4, TDO_NO, final_send_data);
+					//1009: FIX BUG
+					memset(send_data, 0, MAX_BUFFER_SIZE);
+#endif
+
+				}
+				bit_len_to_send=0;
+				
+				//reset parameters, only can have one read cmd, since, when we meet read cmd, we will send it immediately
+				m=0;
+				bit_copy(&send_data[m], 0, &(cableserver_client_ctx->write_buffer[i+3]), 0, w_header_bitlen*4);
+				flip_array(send_data, w_header_bitlen);
+
+#ifdef BRIDGE_4_BIT_UNIT
+				
+
+				if(dr_flag ==1 &&
+					bit_last_flag==1){
+					bit_last_flag=0;
+					dr_flag=0;
+					#ifdef debug_on
+					fprintf(stderr, "w_header_bitlen=%d\n",w_header_bitlen);
+					#endif
+				
+				}
+	#ifdef debug_on
+					fprintf(stderr, "before send(GET tdo), bitlen=%d\n",w_header_bitlen);
+					for (int s1_i=0; s1_i<(w_header_bitlen*4+7)/8; s1_i++){
+						fprintf(stderr, " 0x%02x", send_data[s1_i]);
+					}
+					fprintf(stderr, "\n");
+	#endif
+				//SWWA FOR XO3D
+				unsigned char addedbit=0;
+			#ifdef debug_on
+				if (w_header_bitlen==1){
+					send_data[0] |= send_data[0]<<4;
+					send_data[0] = send_data[0]&0xFB;
+					//#ifdef debug_on
+					fprintf(stderr, "added 1*4bit= 0x%02x\n", send_data[0]);
+					//#endif
+					addedbit=4;
+				}
+			#endif
+				swwa_add_header_bit(send_data, w_header_bitlen, final_send_data_swwa);
+				//addedbit+=daisy_chain_ctx->header_len;
+				//cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, w_header_bitlen*4, TDO_YES, send_data);
+				cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, w_header_bitlen*4+addedbit+daisy_chain_ctx->header_len, TDO_YES, final_send_data_swwa);
+				memset(received_data, 0, MAX_BUFFER_SIZE);
+				//cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, received_data, w_header_bitlen*4);
+				cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, received_data, w_header_bitlen*4+addedbit+daisy_chain_ctx->header_len);
+				//cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, received_data, w_header_bitlen*4+addedbit+daisy_chain_ctx->header_len);
+				memset(send_data, 0, MAX_BUFFER_SIZE);
+
+				
+				//#ifdef debug_on
+				if(gdb_input_flag==1){
+					fprintf(stderr, "get tdo, bitlen=%d\n",w_header_bitlen+addedbit);
+					for (int r_i=0; r_i<(w_header_bitlen*4+7+addedbit+daisy_chain_ctx->header_len)/8;r_i++){
+					//for (int r_i=0; r_i<(w_header_bitlen*4+7+addedbit+daisy_chain_ctx->header_len)/8;r_i++){
+						fprintf(stderr, " 0x%02x", received_data[r_i]);
+					}
+					fprintf(stderr, "\n");
+				}
+			//	if (w_header_bitlen>1){
+					//(w_header_bitlen+1)/4= the last byte
+					//fprintf(stderr, "the last byte: received_data[%d]=0x%02x\n",(w_header_bitlen+1)/4, received_data[(w_header_bitlen+1)/4]);
+			//		last_byte_1020= received_data[(w_header_bitlen+1)/4];
+			//	}else{
+			//		received_data[0]=last_byte_1020;
+			//	}
+
+				
+				//if(w_header_bitlen==1){
+				//	received_data[0]=received_data[1];
+				//}
+				//fprintf(stderr, "\n");
+				//#endif
+#else
+				unsigned added_bit_len=0;
+				#ifdef debug_on
+					fprintf(stderr, "before send(GET tdo), bitlen=%d\n",w_header_bitlen);
+					for (int s1_i=0; s1_i<(w_header_bitlen*4+7)/8; s1_i++){
+						fprintf(stderr, " 0x%02x", send_data[s1_i]);
+					}
+					fprintf(stderr, "\n");
+				#endif
+
+				added_bit_len = swwa_add_trailer_header_bit(send_data, w_header_bitlen, final_send_data);
+				
+				#ifdef debug_on
+					fprintf(stderr, "converted, before send(GET tdo), bitlen=%d\n",w_header_bitlen+added_bit_len);
+					for (int s_i=0; s_i<(w_header_bitlen*4+added_bit_len+7)/8; s_i++){
+						fprintf(stderr, " 0x%02x", final_send_data[s_i]);
+					}
+					fprintf(stderr, "\n");
+				#endif
+
+				cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, w_header_bitlen*4+added_bit_len, TDO_YES, final_send_data);
+				//1009: FIX BUG
+				memset(send_data, 0, MAX_BUFFER_SIZE);
+				cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, received_data, w_header_bitlen*4+added_bit_len);
+				
+			
+				#ifdef debug_on
+					fprintf(stderr, "get tdo, bitlen=%d\n",w_header_bitlen);
+					for (int r_i=0; r_i<(w_header_bitlen*4+added_bit_len+7)/8;r_i++){
+						fprintf(stderr, " 0x%02x", received_data[r_i]);
+					}
+					fprintf(stderr, "\n");
+				#endif
+#endif
+				
+				//assign shift_enable_wire = (((bscan_SHIFT & bscan_SEL) == 1'd1) && ((TCK_counter_reg_Q0 != 2'd0) || ((TCK_counter_reg_Q0 == 2'd0) && (TDI_reg2_Q0 == 1'd1)))) ;
+				
+				memset(received_data_test, 0, MAX_BUFFER_SIZE+1);
+				#if 1
+					#ifdef BRIDGE_4_BIT_UNIT
+					unsigned trailer_bit_len=(daisy_chain_ctx->header_len>daisy_chain_ctx->trailer_len) ? daisy_chain_ctx->header_len : daisy_chain_ctx->trailer_len;
+					//fprintf(stderr, "shift bit=%d\n", trailer_bit_len);
+					#else
+					unsigned trailer_bit_len=daisy_chain_ctx->num-1;
+					#endif
+					
+					#ifdef debug_on
+						printf("trailer_bit_len=%d\n", trailer_bit_len);
+					#endif
+					uint8_t tmp_data=0;
+					for (int lo_i=0; lo_i<(w_header_bitlen*4+7+daisy_chain_ctx->header_len)/8; lo_i++){
+						
+						received_data_test[lo_i]=received_data[lo_i]>>trailer_bit_len;
+						received_data_test[lo_i]&=(0xFF>>trailer_bit_len); //clear to 0,  hight 2 bit
+						received_data_test[lo_i]|=(tmp_data&(0xFF>>(8-trailer_bit_len)))<<(8-trailer_bit_len);
+						tmp_data=received_data[lo_i];
+						
+					}
+				#else
+					bit_right_shift(received_data, (w_header_bitlen*4+7+daisy_chain_ctx->header_len)/8);  //right shit 1 bit 
+					memcpy(received_data_test, &received_data[0], ((w_header_bitlen*4+7+daisy_chain_ctx->header_len)/8)*sizeof(unsigned char));
+				#endif
+					
+				memset(received_data, 0, MAX_BUFFER_SIZE);
+
+				if (daisy_chain_ctx->header_len==1){
+					if(w_header_bitlen%2==0) //for XO3D SWWA
+						memcpy(received_data, &received_data_test[1], ((w_header_bitlen*4+7)/8)*sizeof(unsigned char));
+					else
+						memcpy(received_data, &received_data_test[0], ((w_header_bitlen*4+7)/8)*sizeof(unsigned char));
+				}else{
+					memcpy(received_data, &received_data_test[0], ((w_header_bitlen*4+7)/8)*sizeof(unsigned char));
+				}
+				
+				//#ifdef debug_on
+				if(gdb_input_flag==1){
+					fprintf(stderr, "get tdo(shifted), bitlen=%d\n",w_header_bitlen);
+					for (int r_i=0; r_i<(w_header_bitlen*4+7)/8;r_i++){
+						fprintf(stderr, " 0x%02x", received_data[r_i]);
+					}
+					fprintf(stderr, "\n");
+				}
+				//#endif
+				i+=(3+(w_header_bitlen+1)/2); 
+				get_tdo_done=true;
+			}
+		}
+	}
+
+	if(bit_len_to_send>0){ 
+		flip_array(send_data, bit_len_to_send);
+
+#ifdef BRIDGE_4_BIT_UNIT
+		swwa_add_header_bit(send_data, bit_len_to_send, final_send_data_swwa);
+		cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4+daisy_chain_ctx->header_len, TDO_NO, final_send_data_swwa);
+		memset(send_data, 0, MAX_BUFFER_SIZE);
+#else
+		unsigned added_bit_len=0;
+		#ifdef debug_on
+			fprintf(stderr, "before send(NO GET tdo), bitlen=%d\n",bit_len_to_send);
+			for (int s1_i=0; s1_i<(bit_len_to_send*4+7)/8; s1_i++){
+				fprintf(stderr, " 0x%02x", send_data[s1_i]);
+			}
+			fprintf(stderr, "\n");
+		#endif
+
+		added_bit_len = swwa_add_trailer_header_bit(send_data, bit_len_to_send, final_send_data);
+		#ifdef debug_on
+			fprintf(stderr, "converted, before send(NO GET tdo), bitlen=%d\n",bit_len_to_send+added_bit_len);
+			for (int s_i=0; s_i<(bit_len_to_send*4+added_bit_len+7)/8; s_i++){
+				fprintf(stderr, " 0x%02x", final_send_data[s_i]);
+			}
+			fprintf(stderr, "\n");
+		#endif
+
+		cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4+added_bit_len, TDO_NO, final_send_data);
+
+		//1009: FIX BUG
+		memset(send_data, 0, MAX_BUFFER_SIZE);
+#endif
+		bit_len_to_send=0;	
+	}
+	
+	if (get_tdo_done){
+		get_tdo_done=false;
+		unsigned r_bit_offset=0;
+		unsigned r_bit_len=0;
+		r_bit_offset=cableserver_client_ctx->read_buffer[1];
+		r_bit_offset=(r_bit_offset<<8)&0xFF00;
+		r_bit_offset|=cableserver_client_ctx->read_buffer[0];
+		r_bit_len=cableserver_client_ctx->read_buffer[3];
+		r_bit_len=(r_bit_len<<8)&0xFF00;
+		r_bit_len|=cableserver_client_ctx->read_buffer[2];  //not correct
+	
+		if((w_header_flag&WR_BUFF_HEADER_LASTBIT)!=WR_BUFF_HEADER_LASTBIT){
+			unsigned gap=w_header_bitlen-r_bit_len;
+			//#ifdef debug_on
+			//fprintf(stderr, "w_header_bitlen=%d, r_bit_len=%d\n", w_header_bitlen, r_bit_len);
+			//#endif
+			memset(received_data_test, 0, MAX_BUFFER_SIZE+1);
+
+			#if 0//def BRIDGE_4_BIT_UNIT
+				if (pre_last_flag==1){
+					pre_last_flag=0;
+					last_byte_swwa= received_data[(w_header_bitlen*4+7)/8-1-(((r_bit_len+1)*4+7)/8-1)];
+					if(r_bit_len%2==0)
+						last_byte_swwa=(last_byte_swwa>>4);
+					
+				}
+				//if(r_bit_len%2==0){
+				//	if((gap*4+7)/8-1>0)
+				//		last_byte_swwa=received_data[(gap*4+7)/8-1];
+				//	else
+				//		fprintf(stderr, "gap erro <0\n");
+				//}else{
+				//	last_byte_swwa=received_data[(gap*4+7)/8]>>4;
+				//}
+			#endif
+			
+			if(gdb_input_flag==1){
+					fprintf(stderr, "==========gap, bitlen=%d\n",gap);
+			}
+			extract_bridge_data((unsigned char *)(&received_data[(gap*4+7)/8]), r_bit_len*4, received_data_test);  //there is a bug for out_offset, only when received multi fields
+			//memset(received_data_test, 0, MAX_BUFFER_SIZE);
+
+			if(gdb_input_flag==1){
+					fprintf(stderr, "==========in value, bitlen=%d\n",r_bit_len);
+					for (int r_i=0; r_i<(r_bit_len*4+7)/8;r_i++){
+						fprintf(stderr, " 0x%02x", received_data_test[r_i]);
+					}
+					fprintf(stderr, "\n");
+			}
+			bit_copy(cableserver_client_ctx->in_value, 0, received_data_test, 0, r_bit_len);
+			if (ir_in_value){
+				fprintf(stderr, "r_bit_len=%d\n", r_bit_len);
+				fprintf(stderr, "in_value=0x%02x\n", cableserver_client_ctx->in_value[0]);
+			}
+		}else{
+			//#ifdef debug_on
+			//printf("last bit, maybe there is an erro in xo3d chain\n");
+			//#endif
+			//support >4 devices in daisy chain
+			//#ifndef BRIDGE_4_BIT_UNIT
+				int index=0;
+				//index=(daisy_chain_ctx->num-1+4)/8; //the last bit is in this byte
+				
+				cableserver_client_ctx->in_value[(r_bit_offset+7)/8-1]|=((received_data[index]&0x08)>>3)<<(r_bit_offset%8);
+			if (ir_in_value){
+				//fprintf(stderr, "last bit r_bit_len=%d\n", r_bit_len);
+				ir_in_value=0;
+				//fprintf(stderr, "cableserver_client_ctx->in_value[%d]=0x%02x\n", (r_bit_offset+7)/8-1, cableserver_client_ctx->in_value[(r_bit_offset+7)/8-1]);
+				cableserver_client_ctx->in_value[(r_bit_offset+7)/8-1]|=0x31;
+			}
+			//#else
+			//	cableserver_client_ctx->in_value[(r_bit_offset+7)/8-1]|=((last_byte_swwa&0x08)>>3)<<(r_bit_offset%8);
+			//#endif
+		}
+		memset(received_data, 0, MAX_BUFFER_SIZE);
+		memset(received_data_test, 0, MAX_BUFFER_SIZE);
+	}
+
+	memset(cableserver_client_ctx->write_buffer, 0, sizeof(unsigned char)*(cableserver_client_ctx->write_size));
+	memset(cableserver_client_ctx->read_buffer, 0, sizeof(unsigned char)*(cableserver_client_ctx->read_size));
+	cableserver_client_ctx->write_count=0;
+	cableserver_client_ctx->read_count=0;
+	return 0;
+	
+}
+
+static unsigned cableserver_buffer_write(const uint8_t *out, unsigned out_offset, unsigned bit_count){
+	memcpy(&(cableserver_client_ctx->write_buffer[cableserver_client_ctx->write_count]), &(out[out_offset/8]), bit_count/8);
+	cableserver_client_ctx->write_count+=bit_count/8;
+	return 0;
+}
+static unsigned  cableserver_buffer_add_read(uint8_t *in,  unsigned in_offset, unsigned bit_count){
+	//[0-1]:bit_offset, [2-3]:bit_count
+	cableserver_client_ctx->in_value=in;
+	cableserver_client_ctx->read_buffer[0]=(in_offset&0xFF);
+	cableserver_client_ctx->read_buffer[1]=(in_offset&0xFF00)>>8;
+	cableserver_client_ctx->read_buffer[2]=(bit_count&0xFF);
+	cableserver_client_ctx->read_buffer[3]=(bit_count&0xFF00)>>8;
+	return bit_count;
+}
+
+
+void cableserver_clock_tms_cs(const uint8_t *out, unsigned out_offset, 
+		uint8_t *in, unsigned in_offset, unsigned length, bool tdi, bool last_bit){
+	//header: 1byte:r/w flag, 2bytes: package length(half byte as length), total,header length=3, bit length*4=byte length, every 1bit=>4bits
+	//byte: 01 write, 02 write/read, 03 read(actually, need to write to shit out data),00:null, read buffer header only have 2 bytes to descripes the length
+	
+	/* Guarantee buffer space enough for a minimum size transfer */
+	if(cableserver_buffer_write_space()<(((length+1)/2)+3) ||(in&&cableserver_buffer_read_space()<(((length+1)/2)+4))){
+		cableserver_buffer_flush();
+	}
+
+	if (length>0){
+		if(((length+1)/2+3)>MAX_BUFFER_SIZE){
+			LOG_ERROR("ERROR::  cableserver buffer overflow!");
+			return;
+		}
+		uint8_t header_flag=WR_BUFF_HEADER_WRITE;
+		header_flag |= last_bit ? WR_BUFF_HEADER_LASTBIT : WR_BUFF_HEADER_NA;
+		header_flag |= in ? WR_BUFF_HEADER_READ : WR_BUFF_HEADER_NA;
+		cableserver_buffer_write_byte(header_flag);  //0x02:r/w, 0x01:w
+		cableserver_buffer_write_byte(length&0xFF);  //data length. hal byte unit=bit_len
+		cableserver_buffer_write_byte((length&0xFF00)>>8);
+	}
+	
+	while(length>0){
+		//byte transfer
+		unsigned this_bits=length;
+		unsigned out_data=*out;
+		if (this_bits>7)
+			this_bits=7;
+		
+		if (this_bits>0){
+			length-=this_bits;
+			unsigned char tmp=0x01; //always the last bit: 1 valid
+			uint8_t data_out=0x00;
+			switch(this_bits%8){
+				case 0:
+					LOG_ERROR("TMS len=0 for JTAG state machine error");
+					break;
+				case 1:
+					data_out=((out_data&0x01)<<2)|tmp;
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 2:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 3:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 4:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 5:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4);
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4);
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 6:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 7:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp); 
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x40)>>4)|(tmp);
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 8:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x40)>>4)|(tmp); 
+					data_out|=((out_data&0x80)>>1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				default:
+					LOG_ERROR("LSCC:: TMS len>8 for JTAG state machine error");
+					break;
+	
+			}
+			if(in) {//send immediately
+				cableserver_buffer_add_read(in, in_offset, 1);
+				cableserver_buffer_flush();
+			}
+		}	
+	}
+}
+
+void cableserver_clock_tms_cs_out(const uint8_t *out, unsigned out_offset, 
+		unsigned length, bool tdi){
+	cableserver_clock_tms_cs(out, out_offset, NULL, 0, length, tdi, false);
+}
+
+void cableserver_clock_data(const uint8_t *out, unsigned out_offset, uint8_t *in, 
+		unsigned in_offset, unsigned length, unsigned in_bit_len){
+	unsigned tmp_offset=0;
+	//unsigned local_len=length;
+	/* Guarantee buffer space enough for a minimum size transfer */
+	if(cableserver_buffer_write_space()<(((length+1)/2)+3) ||
+		(in&&cableserver_buffer_read_space()<(((length+1)/2)+4)))
+		cableserver_buffer_flush();
+
+	//add header
+	if (length>0){
+		if(((length+1)/2+3)>MAX_BUFFER_SIZE){
+			LOG_ERROR("ERROR::  cableserver buffer overflow!\n");
+			return;
+		}
+		
+		uint8_t header_flag=WR_BUFF_HEADER_WRITE;
+		header_flag |= in ? WR_BUFF_HEADER_READ : WR_BUFF_HEADER_NA;
+		
+		cableserver_buffer_write_byte( header_flag);  //0x02:r/w, 0x01:w
+		cableserver_buffer_write_byte(length&0xFF);  //data length. hal byte unit=bit_len
+		cableserver_buffer_write_byte((length&0xFF00)>>8);
+	}
+	
+	while(length>0){
+		if(length<8){
+			unsigned char tmp=0x01;
+			unsigned char *out_buff=NULL;
+			out_buff=(unsigned char *)malloc(sizeof(unsigned char)*((length+1)/2));
+			memset(out_buff, 0, sizeof(unsigned char)*((length+1)/2));
+			
+			if(out){
+				switch(length){
+					case 0:
+						break;
+					case 1:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						break;
+					case 2:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						break;
+					case 3:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp);
+						break;
+					case 4:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp);
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4);
+						break;
+					case 5:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp);
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4);
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp);
+						break;
+					case 6:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp);
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4);
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp);
+						out_buff[2]|=((out[tmp_offset]&0x20))|(tmp<<4);
+						break;
+					case 7:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4);
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp);
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4);
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp);
+						out_buff[2]|=((out[tmp_offset]&0x20))|(tmp<<4);
+						out_buff[3]=((out[tmp_offset]&0x40)>>5)|(tmp);
+						break;
+					default:
+						LOG_ERROR("TMS len>8 for JTAG state machine error\n");
+						break;
+				}
+				cableserver_buffer_write(out_buff, 0, ((length+1)/2)*8);
+			}
+			
+			if(in){
+				if(!out){
+					memset(out_buff, 0x33, sizeof(unsigned char)*((length+1)/2));
+					cableserver_buffer_write(out_buff, 0, ((length+1)/2)*8);
+				}
+				cableserver_buffer_add_read(in, in_offset, in_bit_len);
+			}
+			
+			if(!out && !in){
+				memset(out_buff, 0x33, sizeof(unsigned char)*((length+1)/2));
+				cableserver_buffer_write(out_buff, 0,  ((length+1)/2)*8);
+			}
+				
+			length=0;
+			free(out_buff);
+			
+		}else{
+			unsigned this_bytes=length/8;
+			tmp_offset+=this_bytes;
+			if(this_bytes*8+3>MAX_BUFFER_SIZE)
+				this_bytes=MAX_BUFFER_SIZE; 	
+
+			if(this_bytes>0){
+				if(out){
+					//before call buffer write, need to convert data to bridge data
+					unsigned char *out_buff=NULL;
+					unsigned char tmp=0x01;
+					out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+					memset(out_buff, 0, sizeof(unsigned char)*(this_bytes*4));
+					
+					for(int i=0; i<this_bytes; i++){
+						out_buff[i*4+0]=((out[out_offset+i]&0x01)<<1)|tmp;			
+						out_buff[i*4+0]|=((out[out_offset+i]&0x02)<<4)|(tmp<<4); 	
+						out_buff[i*4+1]=((out[out_offset+i]&0x04)>>1)|(tmp); 		
+						out_buff[i*4+1]|=((out[out_offset+i]&0x08)<<2)|(tmp<<4); 	
+						out_buff[i*4+2]=((out[out_offset+i]&0x10)>>3)|(tmp); 		
+						out_buff[i*4+2]|=((out[out_offset+i]&0x20))|(tmp<<4); 		
+						out_buff[i*4+3]=((out[out_offset+i]&0x40)>>5)|(tmp); 		
+						out_buff[i*4+3]|=((out[out_offset+i]&0x80)>>2)|(tmp<<4); 	
+					}
+					cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+					free(out_buff);
+				}
+
+				if(in){
+					if(!out){
+						unsigned char *out_buff=NULL;
+						out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+						memset(out_buff, 0x33, sizeof(unsigned char)*(this_bytes*4));
+						
+						cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+						free(out_buff);
+					}
+
+					in_offset+=cableserver_buffer_add_read(in, in_offset, in_bit_len);
+				}
+				if(!out && !in){
+					unsigned char *out_buff=NULL;
+					out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+					memset(out_buff, 0x33, sizeof(unsigned char)*(this_bytes*4));
+					
+					cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+					free(out_buff);
+				}
+				length-=this_bytes*8;
+			}
+		}
+	}
+	if(in){
+		cableserver_buffer_flush();
+	}
+}
+
+static void cableserver_tap_set_end_state(tap_state_t state){
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
+	else {
+		LOG_ERROR("BUG: %s is not a stable end state", tap_state_name(state));
+		exit(-1);
+	}
+}
+
+static void cableserver_tap_move_to_state(tap_state_t goal_state){
+	tap_state_t start_state = tap_get_state();
+
+	/*	goal_state is 1/2 of a tuple/pair of states which allow convenient
+		lookup of the required TMS pattern to move to this state from the
+		start state.
+	*/
+
+	/* do the 2 lookups */
+	uint8_t tms_bits  = tap_get_tms_path(start_state, goal_state);
+	int tms_count = tap_get_tms_path_len(start_state, goal_state);
+	assert(tms_count <= 8);
+
+	DEBUG_JTAG_IO("start=%s goal=%s\n", tap_state_name(start_state), tap_state_name(goal_state));
+
+	/* Track state transitions step by step */
+	for (int i = 0; i < tms_count; i++)
+		tap_set_state(tap_state_transition(tap_get_state(), (tms_bits >> i) & 1));
+	
+	cableserver_clock_tms_cs_out(&tms_bits, 0, tms_count, false);
+}
+
+static void cableserver_execute_scan(struct jtag_command *cmd){
+	static bool first_run=true;
+	DEBUG_JTAG_IO("%s type:%d\n", cmd->cmd.scan->ir_scan ? "IRSCAN" : "DRSCAN", 
+		jtag_scan_type(cmd->cmd.scan));
+
+	/* Make sure there are no trailing fields with num_bits == 0, or the logic below will fail. */
+	while (cmd->cmd.scan->num_fields > 0
+			&& cmd->cmd.scan->fields[cmd->cmd.scan->num_fields - 1].num_bits == 0) {
+		cmd->cmd.scan->num_fields--;
+		DEBUG_JTAG_IO("discarding trailing empty field");
+	}
+
+	if (cmd->cmd.scan->num_fields == 0) {
+		DEBUG_JTAG_IO("empty scan, doing nothing");
+		return;
+	}
+#ifdef debug_on
+	int ir_flag=0;
+#endif
+	//int dr_flag=0;
+
+	if (cmd->cmd.scan->ir_scan) {
+		if (tap_get_state() != TAP_IRSHIFT)
+			cableserver_tap_move_to_state(TAP_IRSHIFT);
+			//fprintf(stderr, "IR shift\n");
+			cmd_dr_flag=0;
+		//	ir_flag=1;
+	} else {
+		if (tap_get_state() != TAP_DRSHIFT)
+			cableserver_tap_move_to_state(TAP_DRSHIFT);
+			//fprintf(stderr,"DR shift\n");
+			cmd_dr_flag=1;
+			//dr_flag=1;
+	}
+
+	cableserver_tap_set_end_state(cmd->cmd.scan->end_state);
+
+	struct scan_field *field = cmd->cmd.scan->fields;
+	unsigned scan_size = 0;
+	uint8_t *out_value=NULL;
+	uint8_t *in_value=NULL;
+	unsigned int dev_num=1;
+	
+#if 0 //SWWA for trailer
+	dev_num=daisy_chain_ctx->trailer_len;
+	//fprintf(stderr, "swwa deb_num=%d\n", dev_num);
+#endif
+
+#ifdef BRIDGE_4_BIT_UNIT
+//	if (cmd_dr_flag==1)
+		dev_num=daisy_chain_ctx->num;
+	//fprintf(stderr, "swwa deb_num=%d\n", dev_num);
+#endif
+	for (int i = 0; i < cmd->cmd.scan->num_fields; i++, field++) {
+		scan_size += field->num_bits;
+		DEBUG_JTAG_IO("%s%s field %d/%d %d bits",
+			field->in_value ? "in" : "", 
+			field->out_value ? "out" : "", 
+			i, 
+			cmd->cmd.scan->num_fields, 
+			field->num_bits);
+#if 0
+		fprintf(stderr, "%s%s field %d/%d %d bits\n",
+			field->in_value ? "in" : "", 
+			field->out_value ? "out" : "", 
+			i, 
+			cmd->cmd.scan->num_fields, 
+			field->num_bits);
+#endif
+		
+		#ifdef debug_on
+		if ((ir_flag==1) && (field->in_value!=NULL)){
+			fprintf(stderr, "%s%s field %d/%d %d bits\n",
+				field->in_value ? "in" : "", 
+				field->out_value ? "out" : "", 
+				i, 
+				cmd->cmd.scan->num_fields, 
+				field->num_bits);
+			ir_in_value=1;
+		}
+		
+
+		if ((dr_flag==1) && (field->in_value!=NULL)){
+			fprintf(stderr, "%s%s field %d/%d %d bits\n",
+				field->in_value ? "in" : "", 
+				field->out_value ? "out" : "", 
+				i, 
+				cmd->cmd.scan->num_fields, 
+				field->num_bits);
+			dr_in_value=1;
+		}
+		#endif
+		if (field->in_value){
+			//swwa: JTAG header and trailer in bypass mode, only 1 bit is needed, but in lattice JTAG, bridge need 4* bits, so 1 bit can not be passed to lattice jtag.
+			#if 1
+			in_value=calloc((field->num_bits*dev_num+7)/8, sizeof(unsigned char));
+			for (int in_i=0; in_i<dev_num; in_i++){
+				bit_copy(in_value,  field->num_bits*in_i, field->in_value, 0, field->num_bits);
+			}
+			#else
+			in_value=calloc((field->num_bits*3+7)/8, sizeof(uint8_t));
+			bit_copy(in_value, 0, field->in_value, 0, field->num_bits);
+			bit_copy(in_value, field->num_bits, field->in_value, 0, field->num_bits);
+			bit_copy(in_value, field->num_bits*2, field->in_value, 0, field->num_bits);
+			#endif
+		}
+
+		if (field->out_value){
+			#if 1
+			out_value=calloc((field->num_bits*dev_num+7)/8, sizeof(unsigned char));
+			for (int out_i=0; out_i<dev_num; out_i++){
+				bit_copy(out_value,  field->num_bits*out_i, field->out_value, 0, field->num_bits);
+			}
+			#else
+			out_value=calloc((field->num_bits*3+7)/8, sizeof(uint8_t));
+			bit_copy(out_value, 0, field->out_value, 0, field->num_bits);
+			bit_copy(out_value, field->num_bits, field->out_value, 0, field->num_bits);
+			bit_copy(out_value, field->num_bits*2, field->out_value, 0, field->num_bits);
+			#endif
+		}
+
+		if (first_run){
+			first_run=false;
+			cableserver_tap_move_to_state(TAP_RESET);  //rest to init tap id
+			cableserver_tap_move_to_state(TAP_IRSHIFT); //move to ir shift
+			unsigned char id_cmd[1]={0x01}; 				//switch to ID channel, bit_len is 4, first send 3 bit
+			cableserver_clock_data(id_cmd, 0, NULL, 0, 3, 0);
+			cableserver_tap_move_to_state(TAP_DRSHIFT);
+		}
+
+		if (i == cmd->cmd.scan->num_fields - 1 && tap_get_state() != tap_get_end_state()) {
+			/* Last field, and we're leaving IRSHIFT/DRSHIFT. Clock last bit during tap
+			 * movement. This last field can't have length zero, it was checked above. */
+			if (!(field->out_value) && !(field->in_value)&&(field->num_bits>0)){
+
+				uint8_t last_bit = 0;
+				uint8_t tmsbit=0x01;
+				cableserver_clock_data(NULL, 0, NULL, 0,  field->num_bits-1, 0);
+				#ifdef BRIDGE_4_BIT_UNIT
+					//	fprintf(stderr, "set bit last =1\n");
+						bit_last_flag=1;
+						dr_flag=cmd_dr_flag;
+				#endif
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, (last_bit==0x01) ? true : false, true);
+				#ifdef TAP_SWWA_1027
+					tap_set_state(tap_state_transition(tap_get_state(), 1));
+					tmsbit=0x00;
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tap_set_state(tap_state_transition(tap_get_state(), 0));
+				#else
+					//	fprintf(stderr,"jtag 2 idle\n");
+					//set to idle
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tmsbit=0x00;
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tap_set_state(TAP_IDLE);
+				#endif
+			}
+			
+			if(field->in_value){
+				if(!(field->out_value)){
+					uint8_t last_bit = 1;
+					uint8_t tmsbit=0x01;
+					
+					cableserver_clock_data(in_value, 0, field->in_value, 0,  field->num_bits*(dev_num)-1, field->num_bits-1);
+
+					#ifdef BRIDGE_4_BIT_UNIT
+				//	fprintf(stderr, "set bit last =1\n");
+						bit_last_flag=1;
+						dr_flag=cmd_dr_flag;
+					#endif
+					cableserver_clock_tms_cs(&tmsbit, 0, field->in_value, field->num_bits*(dev_num)-1, 1, (last_bit==0x01) ?  true : false, true);
+				//	fprintf(stderr,"jtag 2 idle\n");
+					//set to idle
+					#ifdef TAP_SWWA_1027
+						tap_set_state(tap_state_transition(tap_get_state(), 1));
+						tmsbit=0x00;
+						cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+						tap_set_state(tap_state_transition(tap_get_state(), 0));
+					#else
+						cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+						tmsbit=0x00;
+						cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+						tap_set_state(TAP_IDLE);	
+					#endif
+				}
+			}
+			
+			if (field->out_value){
+				uint8_t last_bit = 0;
+				uint8_t tmsbit=0x01;
+
+				#if 0 //def BRIDGE_4_BIT_UNIT
+					last_bit=((out_value[(field->num_bits*(dev_num)+7)/8-1])>>((((field->num_bits*(dev_num))%8-1)>0) ? ((field->num_bits*(daisy_chain_ctx->num))%8-1) : 0))&0x01;
+					//if (last_bit==1)
+					//	pre_last_flag=1;
+					
+					cableserver_clock_data(out_value, 0, field->in_value, 0,  field->num_bits*(dev_num)-1, field->num_bits-1);
+					cableserver_clock_tms_cs(&tmsbit, 0, field->in_value, field->num_bits*(dev_num)-1, 1, (last_bit==0x01) ? true: false, true);
+				#else
+					cableserver_clock_data(out_value, 0, field->in_value, 0,  field->num_bits*(dev_num)-1, field->num_bits-1);
+					last_bit=((out_value[(field->num_bits*(dev_num)+7)/8-1])>>((((field->num_bits*(dev_num))%8-1)>0) ? ((field->num_bits*(dev_num))%8-1) : 0))&0x01;
+
+					#ifdef BRIDGE_4_BIT_UNIT
+					//	fprintf(stderr, "set bit last =1\n");
+						bit_last_flag=1;
+						dr_flag=cmd_dr_flag;
+					#endif
+
+					cableserver_clock_tms_cs(&tmsbit, 0, field->in_value, field->num_bits*(dev_num)-1, 1, (last_bit==0x01) ? true: false, true);
+				#endif
+				#ifdef TAP_SWWA_1027
+					tap_set_state(tap_state_transition(tap_get_state(), 1));
+					tmsbit=0x00;
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tap_set_state(tap_state_transition(tap_get_state(), 0));
+				#else
+					//set to idle
+					//fprintf(stderr,"jtag 2 idle\n");
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+
+					tmsbit=0x00;
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tap_set_state(TAP_IDLE);	
+				#endif
+			}
+		} else{
+
+			if (!(field->out_value) && !(field->in_value) &&(field->num_bits>0))
+				cableserver_clock_data(NULL, 0, NULL, 0,  field->num_bits, 0);
+			
+			if(field->in_value){
+				if(!(field->out_value))
+					cableserver_clock_data(in_value, 0, field->in_value, 0,  field->num_bits*(dev_num), field->num_bits);
+			}
+			
+			if (field->out_value)
+				cableserver_clock_data(out_value, 0, field->in_value, 0,  field->num_bits*(dev_num), field->num_bits);
+		}		
+	}
+
+	if (tap_get_state() != tap_get_end_state())
+		 cableserver_tap_move_to_state(tap_get_end_state());
+
+	DEBUG_JTAG_IO("%s scan, %i bits, end in %s",(cmd->cmd.scan->ir_scan) ? "IR" : "DR",
+		scan_size,tap_state_name(tap_get_end_state()));
+}
+
+static void cableserver_execute_pathmove(struct jtag_command *cmd){
+	tap_state_t *path = cmd->cmd.pathmove->path;
+	int num_states  = cmd->cmd.pathmove->num_states;
+
+	DEBUG_JTAG_IO("pathmove: %i states, current: %s  end: %s", 
+		num_states,
+		tap_state_name(tap_get_state()),
+		tap_state_name(path[num_states-1]));
+
+	int state_count = 0;
+	unsigned bit_count = 0;
+	uint8_t tms_byte = 0;
+
+
+	/* this loop verifies that the path is legal and logs each state in the path */
+	while (num_states--) {
+
+		/* either TMS=0 or TMS=1 must work ... */
+		if (tap_state_transition(tap_get_state(), false) 
+			== path[state_count])
+			buf_set_u32(&tms_byte, bit_count++, 1, 0x0);
+		else if (tap_state_transition(tap_get_state(), true) 
+			== path[state_count]) {
+			buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
+
+			/* ... or else the caller goofed BADLY */
+		} else {
+			LOG_ERROR("BUG: %s -> %s isn't a valid "
+				"TAP state transition",
+				tap_state_name(tap_get_state()),
+				tap_state_name(path[state_count]));
+			exit(-1);
+		}
+
+		tap_set_state(path[state_count]);
+		state_count++;
+
+		if (bit_count == 7 || num_states == 0) {
+			cableserver_clock_tms_cs_out(&tms_byte, 0, bit_count, false);
+			bit_count = 0;
+		}
+	}
+	tap_set_end_state(tap_get_state());
+}
+
+static void cableserver_execute_statemove(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("statemove end in %s",
+		tap_state_name(cmd->cmd.statemove->end_state));
+
+	cableserver_tap_set_end_state(cmd->cmd.statemove->end_state);
+
+	/* shortest-path move to desired end state */
+	if (tap_get_state() != tap_get_end_state() ||
+		tap_get_end_state() == TAP_RESET)
+		 cableserver_tap_move_to_state(tap_get_end_state());
+}
+
+static void cableserver_execute_stableclocks(struct jtag_command *cmd){
+	/* this is only allowed while in a stable state.  A check for a stable
+	 * state was done in jtag_add_clocks()
+	 */
+	int num_cycles = cmd->cmd.stableclocks->num_cycles;
+	/* 7 bits of either ones or zeros. */
+	uint8_t tms = tap_get_state() == TAP_RESET ? 0x7f : 0x00;
+	
+
+	/* TODO: Use mpsse_clock_data with in=out=0 for this, if TMS can be set to
+	 * the correct level and remain there during the scan */
+	while (num_cycles > 0) {
+		unsigned this_len = num_cycles > 7 ? 7 : num_cycles;
+		cableserver_clock_tms_cs_out(&tms, 0, this_len, false);
+		/* there are no state transitions in this code, so omit state tracking */
+		num_cycles -= this_len;
+	}
+
+	DEBUG_JTAG_IO("clocks %i while in %s",
+		cmd->cmd.stableclocks->num_cycles,
+		tap_state_name(tap_get_state()));
+
+}
+
+static void cableserver_execute_runtest(struct jtag_command *cmd){
+	int i;
+	uint8_t zero = 0;
+
+	DEBUG_JTAG_IO("runtest %i cycles, end in %s",
+		cmd->cmd.runtest->num_cycles,
+		tap_state_name(cmd->cmd.runtest->end_state));
+
+	if (tap_get_state() != TAP_IDLE)
+		 cableserver_tap_move_to_state(TAP_IDLE);
+
+	/* TODO: Reuse ftdi_execute_stableclocks */
+	i = cmd->cmd.runtest->num_cycles;
+	while (i > 0) {
+		/* there are no state transitions in this code, so omit state tracking */
+		unsigned this_len = i > 7 ? 7 : i;
+		cableserver_clock_tms_cs_out(&zero, 0, this_len, false);
+		i -= this_len;
+	}
+	cableserver_tap_set_end_state(cmd->cmd.runtest->end_state);
+
+	if (tap_get_state() != tap_get_end_state())
+		 cableserver_tap_move_to_state(tap_get_end_state());
+
+	DEBUG_JTAG_IO("runtest: %i, end in %s",
+		cmd->cmd.runtest->num_cycles,
+		tap_state_name(tap_get_end_state()));
+}
+
+static void cableserver_execute_reset(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("reset trst: %i srst %i\n",
+		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+
+	if (cmd->cmd.reset->trst == 1
+	    || (cmd->cmd.reset->srst
+		&& (jtag_get_reset_config() & RESET_SRST_PULLS_TRST))){
+		tap_set_state(TAP_RESET);
+	}
+	 cableserver_tap_move_to_state(TAP_RESET);
+
+	DEBUG_JTAG_IO("trst: %i, srst: %i",
+		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+}
+
+static void cableserver_execute_sleep(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("sleep %" PRIi32, cmd->cmd.sleep->us);
+	jtag_sleep(cmd->cmd.sleep->us);
+	DEBUG_JTAG_IO("sleep %" PRIi32 " usec while in %s",
+		cmd->cmd.sleep->us,
+		tap_state_name(tap_get_state()));
+}
+
+static void cableserver_execute_tms(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("TMS: %d bits", cmd->cmd.tms->num_bits);
+}
+
+static void cableserver_execute_command(struct jtag_command *cmd){
+	switch (cmd->type) {
+			case JTAG_RESET:
+				cableserver_execute_reset(cmd);
+				break;
+			case JTAG_RUNTEST:
+				cableserver_execute_runtest(cmd);
+				break;
+			case JTAG_STABLECLOCKS:
+				cableserver_execute_stableclocks(cmd);
+				break;
+			case JTAG_TLR_RESET:
+				cableserver_execute_statemove(cmd);
+				break;
+			case JTAG_PATHMOVE:
+				cableserver_execute_pathmove(cmd);
+				break;
+			case JTAG_TMS:
+				cableserver_execute_tms(cmd);  
+				break;
+			case JTAG_SLEEP:
+				cableserver_execute_sleep(cmd); 
+				break;
+			case JTAG_SCAN:
+				cableserver_execute_scan(cmd);
+				break;
+			default:
+				break;	
+		}
+}
+
+static void cableserver_close(char *cable, char *port){
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_UnlockCable)!=0){
+		LOG_ERROR("lock cable failed\n");
+		return;
+	}
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_ReleaseCablePort, cable, port, 0) !=0){
+		LOG_ERROR("LSCC::release cable port failed\n");
+		return;
+	}
+}
+
+struct cableserver_client_ctx *cableserver_open(void){
+	HINSTANCE handler_dll = NULL;
+	
+	struct cableserver_client_ctx *ctx=calloc(1, sizeof(*ctx));
+	if(!ctx)
+		return 0;
+
+	char str[1024+256];  //path+name
+	memset(str, '\0', 1024+256);
+   	GetModuleFileNameA(NULL, str, 1024); //openOCD.exe path, include name
+   	strrchr(str, '\\')[1]=0;  //remove openOCD.exe name
+	char *path=strrchr(str, '\\')+1;
+
+	strcpy(path, "cableserver_client.dll");
+	handler_dll = LoadLibrary(str);
+	if (handler_dll==NULL){
+		LOG_ERROR("load lib failed\n");
+		return NULL;
+	}
+
+	//set enviroment
+	strrchr(str, '\\')[1]=0;  //remove openOCD.exe name
+	path=strrchr(str, '\\')+1;
+	strcpy(path, "..\\..\\ispFPGA");
+	char foundry_path[1024+512]="FOUNDRY=";
+	strcpy(foundry_path+8, str);
+   	_putenv(foundry_path);
+
+	ctx->read_size=MAX_BUFFER_SIZE;
+	ctx->write_size=MAX_BUFFER_SIZE;
+	ctx->read_buffer=calloc(1, ctx->read_size);
+	ctx->write_buffer=calloc(1, ctx->write_size);
+	ctx->write_count=0;
+	ctx->read_count=0;
+	ctx->create=(client_create_func)GetProcAddress(handler_dll, "ClientCreate");
+	ctx->connect=(client_connect_func)GetProcAddress(handler_dll, "ClientConnect");
+	ctx->send=(client_send_func)GetProcAddress(handler_dll, "ClientSend");
+	ctx->read=(client_read_func)GetProcAddress(handler_dll, "ClientRead");
+	ctx->get_tdo=(client_get_tdo_func)GetProcAddress(handler_dll, "ClientGetTDO");
+	ctx->get_tdo_u= (client_get_tdo_unsigned_func)GetProcAddress(handler_dll, "ClientGetTDO_U");
+
+	return ctx;
+}
+
+int cableserver_config(void){
+	unsigned char er1_data[1]={0x32};  
+	//unsigned char select_channel[3]={0x00,0x00,0x16}; //selectTCRInstr, ecpENABLE, 21bit   //PROPEL 1.0 CHANNEL 0
+	//unsigned char select_channel[3]={0x04,0x00,0x06}; //selectTCRInstr, ecpENABLE, 24bit // PROPEL 1.1, JEDI CHANNEL 14
+	unsigned char er2_data[1]={0x38};
+	unsigned char enable_nop[2]={0x00, 0x00};
+	char dev_buff[10][256]; //cable list, device list
+	int dev_num;
+	int status;
+	unsigned char *cmd_data; 
+	#if 0
+	//device ID list
+	unsigned char dev_family=DEV_NONE;
+
+	
+
+	fprintf(stderr, "name=%s, id=%s, len=%d, channel=%d\n", dev_family_config[0][0], dev_family_config[0][1], atoi(dev_family_config[0][2]), atoi(dev_family_config[0][3]));
+	char *JediID="0F1043";//"0x010F1043";
+	char *XO3DID="2E3043";//"0x212E3043";
+	char *ECP5ID="113043";//"0x41113043";
+	char *CertusNXID="0F1043";//"0x310F1043";
+	#endif
+	
+	daisy_chain_ctx=calloc(1, sizeof(struct daisy_chain_device_ctx));
+	daisy_chain_ctx->num=DC_DEV_NUM;
+	daisy_chain_ctx->target=atoi(lattice_target_dev);//DC_TARGET_DEVICE;
+	daisy_chain_ctx->trailer_len=0;
+	daisy_chain_ctx->header_len=0;
+	daisy_chain_ctx->HDR_len=0;
+	daisy_chain_ctx->HIR_len=0;
+	daisy_chain_ctx->TDR_len=0;
+	daisy_chain_ctx->TIR_len=0;
+	daisy_chain_ctx->HDR_data=NULL;
+	daisy_chain_ctx->HIR_data=NULL;
+	daisy_chain_ctx->TDR_data=NULL;
+	daisy_chain_ctx->TIR_data=NULL;
+
+	//create, connect cable
+	cableserver_client_ctx->handle=NULL;
+	cableserver_client_ctx->handle=cableserver_client_ctx->create(lattice_host_name);
+	if (cableserver_client_ctx->handle==NULL){
+		LOG_ERROR("Error:: client create failed\n");
+		return ERROR_FAIL;
+	}
+	//connect to cableserver,  create cableserver process to listen TCP/IP
+	if (cableserver_client_ctx->connect(cableserver_client_ctx->handle, lattice_host_name, NULL, NULL)!=0){
+		LOG_ERROR("Error:: connect to cableserver failed\n");
+		return ERROR_FAIL;
+	}
+
+	//fprintf(stderr, "daisy_chain_ctx->target=%d\n",daisy_chain_ctx->target);
+	
+	//set cable
+	//status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_SetCablePort, lattice_cable, lattice_port, 9,0,0,1,0,0,0,1,30,0);
+	status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_SetCablePort, lattice_cable, lattice_port, 9,0,0,1,0,0,0,1,atoi(lattice_tck_delay),0);
+	//status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_SetCablePort, lattice_cable, lattice_port, 0);
+	if(status <0){
+		LOG_ERROR("Set cable port failed(%d), Please select correct port number (FTUSB-?) from \'Cable List\'.",status);
+		//cableserver_client_ctx->client_disconnect(p_cableserver_client_ctx->p_client_handle);
+		//LOG_ERROR("set cable port failed(%d), please connect it again11\n",status);
+		return ERROR_FAIL;
+	}
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_LockCable)!=0){
+		LOG_ERROR("Lock cable failed\n");
+		return ERROR_FAIL;
+	}
+
+	//scan device
+	memset(dev_buff, '\0', 10*256);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_ScanDeviceChain);
+	cableserver_client_ctx->read(cableserver_client_ctx->handle, dev_buff, &dev_num);
+	
+	#if 1
+	fprintf(stderr, "Device List: \n");
+	for (int i=0; i<dev_num; i++){
+		fprintf(stderr, "    ");
+		for (int j=0; j<100; j++){
+			fprintf(stderr, "%c", dev_buff[i][j]);
+			#if 0
+			if (NULL!=strstr(dev_buff[i], JediID)){
+				dev_family |= DEV_JEDI;
+			}
+
+			if (NULL!= strstr(dev_buff[i], XO3DID)){
+				dev_family |= DEV_XO3D;
+			}
+
+			if (NULL!= strstr(dev_buff[i], ECP5ID)){
+				dev_family |= DEV_ECP5;
+			}
+
+			if (NULL!= strstr(dev_buff[i], CertusNXID)){
+				dev_family |= DEV_RAPTOR;
+			}
+			#endif
+		}
+		fprintf(stderr, "\n");
+	}
+	#endif
+#if 0
+	if (dev_family==DEV_NONE){
+		fprintf(stderr, "Error: Please select correct port number (FTUSB-?) ");
+		return ERROR_FAIL;
+	}
+#endif
+	daisy_chain_ctx->num=dev_num;
+
+	daisy_chain_ctx->trailer_len=daisy_chain_ctx->num-daisy_chain_ctx->target-1;
+	daisy_chain_ctx->header_len=daisy_chain_ctx->target;
+
+	//fprintf(stderr, "info: dev num=%d, trailer_len =%d, header_len=%d\n", daisy_chain_ctx->num, daisy_chain_ctx->trailer_len, daisy_chain_ctx->header_len);
+	
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagTEST_LOGIC_RESET);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+
+	cmd_data=calloc(daisy_chain_ctx->num, sizeof(unsigned char));
+
+	//target JTAG ID read
+#if 0
+	unsigned char id_code=0xE0;  //JTAG ID cmd
+	unsigned char target_id[JTAG_ID_LEN];
+	unsigned char *id_list;
+	//unsigned char id_list[4*10]; //support 10 device in daisy chain.
+
+	id_list=calloc(JTAG_ID_LEN+(daisy_chain_ctx->num-1+7)/8, sizeof(unsigned char));
+	
+	memset(id_list, '\0', JTAG_ID_LEN+(daisy_chain_ctx->num-1+7)/8);
+	
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=id_code;
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, cmd_data);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, JTAG_ID_LEN*8+(daisy_chain_ctx->num-1), TDO_YES, id_list);
+	cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, id_list, JTAG_ID_LEN*8+daisy_chain_ctx->num-1);
+	//array len-trailer-idlen
+	for(int q=0; q<daisy_chain_ctx->trailer_len; q++)
+		bit_right_shift(id_list, JTAG_ID_LEN+(daisy_chain_ctx->num-1+7)/8);
+	bit_copy(target_id, 0, id_list, (daisy_chain_ctx->num-1+7)/8, JTAG_ID_LEN*8);
+	//unsigned src_offset=(JTAG_ID_LEN+(daisy_chain_ctx->num+7)/8)*8-(daisy_chain_ctx->trailer_len)-JTAG_ID_LEN*8;
+	//bit_copy(target_id, 0, id_list, src_offset, JTAG_ID_LEN*8);
+	
+	
+	
+	fprintf(stderr, "Target Device(%d) ID: 0x", daisy_chain_ctx->target);
+	for(int id_i=0; id_i<JTAG_ID_LEN; id_i++){
+		fprintf(stderr, "%02X", target_id[id_i]);
+	}
+	fprintf(stderr,"\n");
+	
+	#if 0
+	if (id_list[1]==0xff &&
+		id_list[2]==0xff&&
+		id_list[3]==0xff){
+		fprintf(stderr, "Error: Please select correct port number (FTUSB-?) from \'Cable List\'.");
+		return ERROR_FAIL;
+	}
+	#endif
+	free(id_list);
+#endif
+	
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+
+	//er1 configure
+	//er1 cmd
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=er1_data[0];
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, cmd_data);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	//select channel
+	unsigned char *select_channel_data=NULL;
+	//unsigned char select_channel[ER2_SELECT_CHANNEL_CMD_LEN]={0x00,0x00,0x16};  //default ://selectTCRInstr, ecpENABLE, 21bit   //PROPEL 1.0 CHANNEL 0
+
+	unsigned char select_channel[ER2_SELECT_CHANNEL_CMD_LEN]={0x00,0x00,0x06};  //default ://selectTCRInstr, ecpENABLE, 21bit   //PROPEL 1.0 CHANNEL 0
+	//unsigned channel_data_bitlen=0;
+	#if 0
+	
+	if (DEV_JEDI == (dev_family&DEV_JEDI)){
+		select_channel[0]=0x04;
+		select_channel[1]=0x00;
+		select_channel[2]=0x06;
+		channel_data_bitlen=24; 
+		//unsigned char select_channel[3]={0x04,0x00,0x06}; //selectTCRInstr, ecpENABLE, 24bit // PROPEL 1.1, JEDI CHANNEL 14
+		//cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 24, TDO_NO, select_channel);
+		//fprintf(stderr, "jedi select channel\n");
+	}
+	else if (DEV_XO3D == (dev_family&DEV_XO3D) &&
+		DEV_RAPTOR != (dev_family&DEV_RAPTOR)){
+		select_channel[0]=0x00;
+		select_channel[1]=0x00;
+		select_channel[2]=0x16;
+		channel_data_bitlen=21;
+		//unsigned char select_channel[3]={0x00,0x00,0x16}; //selectTCRInstr, ecpENABLE, 21bit   //PROPEL 1.0 CHANNEL 0
+		//cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 21, TDO_NO, select_channel);
+		//fprintf(stderr, "sentry select channel\n");
+	}else if(DEV_RAPTOR == (dev_family&DEV_RAPTOR)){
+		select_channel[0]=0x04;
+		select_channel[1]=0x00;
+		select_channel[2]=0x06;
+		channel_data_bitlen=24;
+		//unsigned char select_channel[3]={0x04,0x00,0x06}; //selectTCRInstr, ecpENABLE, 24bit // PROPEL 1.1, JEDI CHANNEL 14
+		//if (daisy_chain_ctx->target==1){
+		//	unsigned char select_chnl_cmd[6]={0x00, 0x00, 0x00, 0x04,0x00,0x06};
+		//	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 24*2, TDO_NO, select_chnl_cmd);
+		//}else{
+		//	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 24, TDO_NO, select_channel);
+		//}//cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 24, TDO_NO, select_channel);
+		//fprintf(stderr, "Rapter select channel\n");
+	}else{
+		fprintf(stderr, "ERR: not support this device in lattice device family\n");
+		return ERROR_FAIL;
+	}
+#endif
+	int target_index=0;
+	for (target_index=0; target_index<DEV_FAMILY_NUM; target_index++){
+		if(NULL!= strstr(dev_buff[daisy_chain_ctx->target],  dev_family_config[target_index][1]))
+			break;
+	}
+
+	if (target_index>=DEV_FAMILY_NUM)
+		fprintf(stderr, "Err: can not found the device from device family database.\n");
+
+	//unsigned data_len=(channel_data_bitlen+daisy_chain_ctx->num-1+7)/8;  //minus self len bit 1
+	
+	unsigned data_len=(atoi(dev_family_config[target_index][2])+daisy_chain_ctx->num-1+7)/8;  //minus self len bit 1
+	//printf("data_len=%d\n", data_len);
+	select_channel_data=calloc(data_len, sizeof(unsigned char));
+	memset(select_channel_data, 0, data_len*sizeof(unsigned char));
+	
+
+
+	if (NULL == strstr(lattice_channel,"NA")){
+		memcpy(dev_family_config[target_index][3], lattice_channel, strlen(lattice_channel));
+		//dev_family_config[target_index][3]=lattice_channel;
+	}
+
+	//char tmp=0xff;
+	//bit_copy(select_channel, 19-atoi(dev_family_config[target_index][3]), &tmp, 0, 1); //set relative bit to 1 to set channel. 00000000 00000000 0000(chnnl 0) 0110
+	if (atoi(dev_family_config[target_index][3])<4)
+		select_channel[2] |= 0x01<<(4+atoi(dev_family_config[target_index][3]));
+
+	if (atoi(dev_family_config[target_index][3])>3 && atoi(dev_family_config[target_index][3])<12)
+		select_channel[1] |= 0x01<<(atoi(dev_family_config[target_index][3])-4);
+
+	if (atoi(dev_family_config[target_index][3])>11 && atoi(dev_family_config[target_index][3])<20)
+		select_channel[0] |= 0x01<<(atoi(dev_family_config[target_index][3])-12);
+
+	//fprintf(stderr,"0x%02x%02x%02x\n", select_channel[0],select_channel[1],select_channel[2]);
+	
+	//bit_copy(select_channel_data, (data_len-ER2_SELECT_CHANNEL_CMD_LEN)*8, select_channel, 0, ER2_SELECT_CHANNEL_CMD_LEN*8);
+	bit_copy(select_channel_data, (data_len-ER2_SELECT_CHANNEL_CMD_LEN)*8, select_channel, 0, ER2_SELECT_CHANNEL_CMD_LEN*8);
+	
+	
+		
+	for(int i=0; i<daisy_chain_ctx->trailer_len; i++){
+		bit_left_shift(select_channel_data, data_len);
+	}
+	//only copy last 3 byte to channel data
+	//bit_copy(select_channel_data, (data_len-ER2_SELECT_CHANNEL_CMD_LEN)*8, select_channel, 0, ER2_SELECT_CHANNEL_CMD_LEN*8);
+#if 0
+	fprintf(stderr, "select channel cmd: 0x");
+	for (int se_i=0; se_i<data_len; se_i++){
+		fprintf(stderr,"%02x", select_channel_data[se_i]);
+	}
+	fprintf(stderr, "\n");
+#endif
+	//printf("select channel data=0x%02x,%02x,%02x, %02x\n", select_channel_data[0],select_channel_data[1],select_channel_data[2], select_channel_data[3]);
+
+	//there is a bug. single xo3d CHIP should 21 bits
+	//cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, channel_data_bitlen+daisy_chain_ctx->num-1, TDO_NO, select_channel_data);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, atoi(dev_family_config[target_index][2])+daisy_chain_ctx->num-1, TDO_NO, select_channel_data);
+	free(select_channel_data);
+
+	//set nop
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=enable_nop[0];
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, enable_nop);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+
+
+	//enable er2
+	//fprintf(stderr, "num=%d\n",daisy_chain_ctx->num);
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=er2_data[0];
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, cmd_data);
+	
+	free(cmd_data);
+	return ERROR_OK;
+}
+
+void cableserver_proc_exit(void){ //WIN, kill process cableserver.exe
+	HANDLE process_list = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+
+	PROCESSENTRY32 process_entry;
+	process_entry.dwSize = sizeof(PROCESSENTRY32);
+
+	//get the first process
+	if (false == Process32First(process_list, &process_entry))
+		return;
+
+	while (Process32Next(process_list, &process_entry)){
+		if(strcmp(process_entry.szExeFile, "cableserver.exe") == 0){
+			uint32_t process_id = process_entry.th32ProcessID;
+			HANDLE process_handle = OpenProcess(PROCESS_TERMINATE, false, process_id);
+			TerminateProcess(process_handle, 0);
+			CloseHandle(process_handle);
+			break;
+		}
+	}
+}
+
+static int lscc_cableserver_execute_queue(void)
+{
+	for (struct jtag_command *cmd = jtag_command_queue; cmd; cmd = cmd->next) {
+		/* fill the write buffer with the desired command */
+		cableserver_execute_command(cmd);
+	}
+
+	int retval = cableserver_buffer_flush();
+	if (retval != ERROR_OK)
+		LOG_ERROR("error while flushing MPSSE queue: %d", retval);
+	return retval;
+}
+
+static int lscc_cableserver_speed(int speed){
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_khz(int khz, int *jtag_speed){
+	*jtag_speed = khz;
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_speed_div(int speed, int *khz){
+	*khz = speed;
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_init(void){
+	cableserver_proc_exit();
+	cableserver_client_ctx= cableserver_open();
+	if (!cableserver_client_ctx)
+		return ERROR_JTAG_INIT_FAILED;
+	return cableserver_config();//isp tracy config  
+}
+
+static int lscc_cableserver_quit(void){
+	DEBUG_JTAG_IO("cableserver_quit");
+	cableserver_close("USB2", "FTUSB-0");
+	free(cableserver_client_ctx);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_server_info_command){
+	DEBUG_JTAG_IO("lattice cable server info version: RC1");
+	fprintf(stderr,"lattice driver version: 1.0.0.0\n");
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_port_select_command){
+	DEBUG_JTAG_IO("lattice_cable_port_select_command");
+	lattice_port = strdup(CMD_ARGV[0]);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_target_dev_select_command){
+	DEBUG_JTAG_IO("lattice_cable_target_dev_select_command");
+	lattice_target_dev = strdup(CMD_ARGV[0]);
+	//fprintf(stderr, "lattice_target_dev=%s\n", lattice_target_dev);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_tck_delayt_command){
+	DEBUG_JTAG_IO("lattice_cable_tck_delayt_command");
+	lattice_tck_delay = strdup(CMD_ARGV[0]);
+	//fprintf(stderr, "lattice_tck_delay=%s\n", lattice_tck_delay);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_jtag_channel_command){
+	DEBUG_JTAG_IO("lattice_cable_jtag_channel_command");
+	lattice_channel = strdup(CMD_ARGV[0]);
+	//fprintf(stderr, "lattice_jtag_channel=%s\n", lattice_channel);
+	return ERROR_OK;
+}
+
+static const struct command_registration lscc_cableserver_cmd_handlers[] = {
+	{
+		.name = "lattice_driver_version",
+		.handler = lattice_cable_server_info_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the lattice cable description of the lattice driver",
+		.usage = "description-string",
+	},
+
+	//cable configuration
+	{
+		.name = "lattice_port_select",
+		.handler = lattice_cable_port_select_command,
+		.mode = COMMAND_CONFIG,
+		.help = "cable port select",
+		.usage = "vid pid vid_uninit pid_uninit",
+	},
+
+	{
+		.name = "lattice_target_dev_select",
+		.handler = lattice_cable_target_dev_select_command,
+		.mode = COMMAND_CONFIG,
+		.help = "cable target device select",
+		.usage = "vid pid vid_uninit pid_uninit",
+	},
+
+	{
+		.name = "lattice_tck_delay",
+		.handler = lattice_cable_tck_delayt_command,
+		.mode = COMMAND_CONFIG,
+		.help = "cable tck delay set",
+		.usage = "vid pid vid_uninit pid_uninit",
+	},
+
+	
+	{
+		.name = "lattice_jtaghub_channel_select",
+		.handler = lattice_cable_jtag_channel_command,
+		.mode = COMMAND_CONFIG,
+		.help = "cable jtag channel select",
+		.usage = "vid pid vid_uninit pid_uninit",
+	},
+	
+	COMMAND_REGISTRATION_DONE
+};
+
+static const char * const lscc_transports[] = {"swd", "jtag", NULL};
+
+//************************lattice cableserver interface*************************************
+//
+//vexRiscV component==>lattice driver(JTAG logic, cableserver client logic, ispTracy logic, bridge logic)
+//==>cableserver==>ispTracy==>bridge==>JTAG==>debug module==>vexRiscV core
+//
+//*********************************end************************************************
+struct jtag_interface lscc_cableserver_interface = {
+	.name = "lattice-usb-cableserver",
+	.commands = lscc_cableserver_cmd_handlers,  
+	.transports = jtag_only,
+	.execute_queue = lscc_cableserver_execute_queue,
+	.speed = lscc_cableserver_speed,
+	.speed_div = lscc_cableserver_speed_div,
+	.khz = lscc_cableserver_khz,
+	.init = lscc_cableserver_init,
+	.quit = lscc_cableserver_quit,
+};
+
diff --git a/src/jtag/drivers/lattice_usb_cableserver/lscc_cableserver_client.h b/src/jtag/drivers/lattice_usb_cableserver/lscc_cableserver_client.h
new file mode 100644
index 0000000..766c16e
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/lscc_cableserver_client.h
@@ -0,0 +1,61 @@
+#ifndef LATTICE_CABLESERVER_CLIENT
+#define LATTICE_CABLESERVER_CLIENT
+
+#define CABLESERVER_CLIENT_EXPORTS
+
+
+#ifdef CABLESERVER_CLIENT_EXPORTS
+#define CABLESERVER_CLIENT_API __declspec(dllexport)
+#else
+#define CABLESERVER_CLIENT_API __declspec(dllimport)
+#endif
+
+#if 0
+typedef void* (*lattice_client_create_func)();
+typedef int (*lattice_client_connect_func)(void* client_handler, char* a_chrHostName, const char* a_chrFileName, const char* a_chrCableServerDir);
+
+typedef struct  {
+	lattice_client_create_func lscc_client_create;
+	lattice_client_connect_func lscc_client_connect;
+} cableserver_client_interface;
+#endif
+
+#if 1
+// Includes and typedefs needed by lattice header
+#ifdef __cplusplus
+extern "C" {
+#endif  // __cplusplus
+
+CABLESERVER_CLIENT_API void* ClientCreate(void);
+CABLESERVER_CLIENT_API int ClientConnect(void* client_handler, char* a_chrHostName, const char* a_chrFileName, const char*a_chrCableServerDir);
+
+#ifdef __cplusplus
+}
+#endif  // __cplusplus
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif  //LATTICE_CLIENT
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index a26c868..a4c4aaf 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -1,252 +1,264 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath@gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 yvind Harboe                                 *
- *   oyvind.harboe@zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2009 SoftPLC Corporation                                *
- *       http://softplc.com                                                *
- *   dick@softplc.com                                                      *
- *                                                                         *
- *   Copyright (C) 2009 Zachary T Welch                                    *
- *   zw@superlucidity.net                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
- ***************************************************************************/
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "interfaces.h"
-
-/** @file
- * This file includes declarations for all built-in jtag interfaces,
- * which are then listed in the jtag_interfaces array.
- *
- * Dynamic loading can be implemented be searching for shared libraries
- * that contain a jtag_interface structure that can added to this list.
- */
-
-#if BUILD_ZY1000 == 1
-extern struct jtag_interface zy1000_interface;
-#elif defined(BUILD_MINIDRIVER_DUMMY)
-extern struct jtag_interface minidummy_interface;
-#else /* standard drivers */
-#if BUILD_PARPORT == 1
-extern struct jtag_interface parport_interface;
-#endif
-#if BUILD_DUMMY == 1
-extern struct jtag_interface dummy_interface;
-#endif
-extern struct jtag_interface jtag_tcp_interface;
-#if BUILD_FTDI == 1
-extern struct jtag_interface ftdi_interface;
-#endif
-#if BUILD_USB_BLASTER == 1 || BUILD_USB_BLASTER_2 == 1
-extern struct jtag_interface usb_blaster_interface;
-#endif
-#if BUILD_JTAG_VPI == 1
-extern struct jtag_interface jtag_vpi_interface;
-#endif
-#if BUILD_FT232R == 1
-extern struct jtag_interface ft232r_interface;
-#endif
-#if BUILD_AMTJTAGACCEL == 1
-extern struct jtag_interface amt_jtagaccel_interface;
-#endif
-#if BUILD_EP93XX == 1
-extern struct jtag_interface ep93xx_interface;
-#endif
-#if BUILD_AT91RM9200 == 1
-extern struct jtag_interface at91rm9200_interface;
-#endif
-#if BUILD_GW16012 == 1
-extern struct jtag_interface gw16012_interface;
-#endif
-#if BUILD_PRESTO
-extern struct jtag_interface presto_interface;
-#endif
-#if BUILD_USBPROG == 1
-extern struct jtag_interface usbprog_interface;
-#endif
-#if BUILD_OPENJTAG == 1
-extern struct jtag_interface openjtag_interface;
-#endif
-#if BUILD_JLINK == 1
-extern struct jtag_interface jlink_interface;
-#endif
-#if BUILD_VSLLINK == 1
-extern struct jtag_interface vsllink_interface;
-#endif
-#if BUILD_RLINK == 1
-extern struct jtag_interface rlink_interface;
-#endif
-#if BUILD_ULINK == 1
-extern struct jtag_interface ulink_interface;
-#endif
-#if BUILD_ARMJTAGEW == 1
-extern struct jtag_interface armjtagew_interface;
-#endif
-#if BUILD_BUSPIRATE == 1
-extern struct jtag_interface buspirate_interface;
-#endif
-#if BUILD_REMOTE_BITBANG == 1
-extern struct jtag_interface remote_bitbang_interface;
-#endif
-#if BUILD_HLADAPTER == 1
-extern struct jtag_interface hl_interface;
-#endif
-#if BUILD_OSBDM == 1
-extern struct jtag_interface osbdm_interface;
-#endif
-#if BUILD_OPENDOUS == 1
-extern struct jtag_interface opendous_interface;
-#endif
-#if BUILD_SYSFSGPIO == 1
-extern struct jtag_interface sysfsgpio_interface;
-#endif
-#if BUILD_AICE == 1
-extern struct jtag_interface aice_interface;
-#endif
-#if BUILD_BCM2835GPIO == 1
-extern struct jtag_interface bcm2835gpio_interface;
-#endif
-#if BUILD_CMSIS_DAP == 1
-extern struct jtag_interface cmsis_dap_interface;
-#endif
-#if BUILD_KITPROG == 1
-extern struct jtag_interface kitprog_interface;
-#endif
-#if BUILD_IMX_GPIO == 1
-extern struct jtag_interface imx_gpio_interface;
-#endif
-#if BUILD_XDS110 == 1
-extern struct jtag_interface xds110_interface;
-#endif
-#endif /* standard drivers */
-
-/**
- * The list of built-in JTAG interfaces, containing entries for those
- * drivers that were enabled by the @c configure script.
- *
- * The list should be defined to contain either one minidriver interface
- * or some number of standard driver interfaces, never both.
- */
-struct jtag_interface *jtag_interfaces[] = {
-#if BUILD_ZY1000 == 1
-		&zy1000_interface,
-#elif defined(BUILD_MINIDRIVER_DUMMY)
-		&minidummy_interface,
-#else /* standard drivers */
-#if BUILD_PARPORT == 1
-		&parport_interface,
-#endif
-#if BUILD_DUMMY == 1
-		&dummy_interface,
-#endif
-		&jtag_tcp_interface,
-#if BUILD_FTDI == 1
-		&ftdi_interface,
-#endif
-#if BUILD_USB_BLASTER || BUILD_USB_BLASTER_2 == 1
-		&usb_blaster_interface,
-#endif
-#if BUILD_JTAG_VPI == 1
-		&jtag_vpi_interface,
-#endif
-#if BUILD_FT232R == 1
-		&ft232r_interface,
-#endif
-#if BUILD_AMTJTAGACCEL == 1
-		&amt_jtagaccel_interface,
-#endif
-#if BUILD_EP93XX == 1
-		&ep93xx_interface,
-#endif
-#if BUILD_AT91RM9200 == 1
-		&at91rm9200_interface,
-#endif
-#if BUILD_GW16012 == 1
-		&gw16012_interface,
-#endif
-#if BUILD_PRESTO
-		&presto_interface,
-#endif
-#if BUILD_USBPROG == 1
-		&usbprog_interface,
-#endif
-#if BUILD_OPENJTAG == 1
-		&openjtag_interface,
-#endif
-#if BUILD_JLINK == 1
-		&jlink_interface,
-#endif
-#if BUILD_VSLLINK == 1
-		&vsllink_interface,
-#endif
-#if BUILD_RLINK == 1
-		&rlink_interface,
-#endif
-#if BUILD_ULINK == 1
-		&ulink_interface,
-#endif
-#if BUILD_ARMJTAGEW == 1
-		&armjtagew_interface,
-#endif
-#if BUILD_BUSPIRATE == 1
-		&buspirate_interface,
-#endif
-#if BUILD_REMOTE_BITBANG == 1
-		&remote_bitbang_interface,
-#endif
-#if BUILD_HLADAPTER == 1
-		&hl_interface,
-#endif
-#if BUILD_OSBDM == 1
-		&osbdm_interface,
-#endif
-#if BUILD_OPENDOUS == 1
-		&opendous_interface,
-#endif
-#if BUILD_SYSFSGPIO == 1
-		&sysfsgpio_interface,
-#endif
-#if BUILD_AICE == 1
-		&aice_interface,
-#endif
-#if BUILD_BCM2835GPIO == 1
-		&bcm2835gpio_interface,
-#endif
-#if BUILD_CMSIS_DAP == 1
-		&cmsis_dap_interface,
-#endif
-#if BUILD_KITPROG == 1
-		&kitprog_interface,
-#endif
-#if BUILD_IMX_GPIO == 1
-		&imx_gpio_interface,
-#endif
-#if BUILD_XDS110 == 1
-		&xds110_interface,
-#endif
-#endif /* standard drivers */
-		NULL,
-	};
-
-void jtag_interface_modules_load(const char *path)
-{
-	/* @todo: implement dynamic module loading for JTAG interface drivers */
-}
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath@gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2007,2008 yvind Harboe                                 *
+ *   oyvind.harboe@zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2009 SoftPLC Corporation                                *
+ *       http://softplc.com                                                *
+ *   dick@softplc.com                                                      *
+ *                                                                         *
+ *   Copyright (C) 2009 Zachary T Welch                                    *
+ *   zw@superlucidity.net                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "interfaces.h"
+
+/** @file
+ * This file includes declarations for all built-in jtag interfaces,
+ * which are then listed in the jtag_interfaces array.
+ *
+ * Dynamic loading can be implemented be searching for shared libraries
+ * that contain a jtag_interface structure that can added to this list.
+ */
+
+#if BUILD_ZY1000 == 1
+extern struct jtag_interface zy1000_interface;
+#elif defined(BUILD_MINIDRIVER_DUMMY)
+extern struct jtag_interface minidummy_interface;
+#else /* standard drivers */
+#if BUILD_PARPORT == 1
+extern struct jtag_interface parport_interface;
+#endif
+#if BUILD_DUMMY == 1
+extern struct jtag_interface dummy_interface;
+#endif
+extern struct jtag_interface jtag_tcp_interface;
+#if BUILD_FTDI == 1
+extern struct jtag_interface ftdi_interface;
+#endif
+#if BUILD_USB_BLASTER == 1 || BUILD_USB_BLASTER_2 == 1
+extern struct jtag_interface usb_blaster_interface;
+#endif
+#if BUILD_JTAG_VPI == 1
+extern struct jtag_interface jtag_vpi_interface;
+#endif
+#if BUILD_FT232R == 1
+extern struct jtag_interface ft232r_interface;
+#endif
+#if BUILD_AMTJTAGACCEL == 1
+extern struct jtag_interface amt_jtagaccel_interface;
+#endif
+#if BUILD_EP93XX == 1
+extern struct jtag_interface ep93xx_interface;
+#endif
+#if BUILD_AT91RM9200 == 1
+extern struct jtag_interface at91rm9200_interface;
+#endif
+#if BUILD_GW16012 == 1
+extern struct jtag_interface gw16012_interface;
+#endif
+#if BUILD_PRESTO
+extern struct jtag_interface presto_interface;
+#endif
+#if BUILD_USBPROG == 1
+extern struct jtag_interface usbprog_interface;
+#endif
+#if BUILD_OPENJTAG == 1
+extern struct jtag_interface openjtag_interface;
+#endif
+#if BUILD_JLINK == 1
+extern struct jtag_interface jlink_interface;
+#endif
+#if BUILD_VSLLINK == 1
+extern struct jtag_interface vsllink_interface;
+#endif
+#if BUILD_RLINK == 1
+extern struct jtag_interface rlink_interface;
+#endif
+#if BUILD_ULINK == 1
+extern struct jtag_interface ulink_interface;
+#endif
+#if BUILD_ARMJTAGEW == 1
+extern struct jtag_interface armjtagew_interface;
+#endif
+//XPDEBUG
+#if BUILD_LSCCCABLESERVER == 1
+extern struct jtag_interface armjtagew_interface;
+#endif
+#if BUILD_BUSPIRATE == 1
+extern struct jtag_interface buspirate_interface;
+#endif
+#if BUILD_REMOTE_BITBANG == 1
+extern struct jtag_interface remote_bitbang_interface;
+#endif
+#if BUILD_HLADAPTER == 1
+extern struct jtag_interface hl_interface;
+#endif
+#if BUILD_OSBDM == 1
+extern struct jtag_interface osbdm_interface;
+#endif
+#if BUILD_OPENDOUS == 1
+extern struct jtag_interface opendous_interface;
+#endif
+#if BUILD_SYSFSGPIO == 1
+extern struct jtag_interface sysfsgpio_interface;
+#endif
+#if BUILD_AICE == 1
+extern struct jtag_interface aice_interface;
+#endif
+#if BUILD_BCM2835GPIO == 1
+extern struct jtag_interface bcm2835gpio_interface;
+#endif
+#if BUILD_CMSIS_DAP == 1
+extern struct jtag_interface cmsis_dap_interface;
+#endif
+#if BUILD_KITPROG == 1
+extern struct jtag_interface kitprog_interface;
+#endif
+#if BUILD_IMX_GPIO == 1
+extern struct jtag_interface imx_gpio_interface;
+#endif
+#if BUILD_XDS110 == 1
+extern struct jtag_interface xds110_interface;
+#endif
+#if BUILD_LSCC_USB_CABLESERVER ==1
+extern struct jtag_interface lscc_cableserver_interface;
+#endif
+#endif /* standard drivers */
+
+/**
+ * The list of built-in JTAG interfaces, containing entries for those
+ * drivers that were enabled by the @c configure script.
+ *
+ * The list should be defined to contain either one minidriver interface
+ * or some number of standard driver interfaces, never both.
+ */
+struct jtag_interface *jtag_interfaces[] = {
+#if BUILD_ZY1000 == 1
+		&zy1000_interface,
+#elif defined(BUILD_MINIDRIVER_DUMMY)
+		&minidummy_interface,
+#else /* standard drivers */
+#if BUILD_PARPORT == 1
+		&parport_interface,
+#endif
+#if BUILD_DUMMY == 1
+		&dummy_interface,
+#endif
+		&jtag_tcp_interface,
+#if BUILD_FTDI == 1
+		&ftdi_interface,
+#endif
+#if BUILD_USB_BLASTER || BUILD_USB_BLASTER_2 == 1
+		&usb_blaster_interface,
+#endif
+#if BUILD_JTAG_VPI == 1
+		&jtag_vpi_interface,
+#endif
+#if BUILD_FT232R == 1
+		&ft232r_interface,
+#endif
+#if BUILD_AMTJTAGACCEL == 1
+		&amt_jtagaccel_interface,
+#endif
+#if BUILD_EP93XX == 1
+		&ep93xx_interface,
+#endif
+#if BUILD_AT91RM9200 == 1
+		&at91rm9200_interface,
+#endif
+#if BUILD_GW16012 == 1
+		&gw16012_interface,
+#endif
+#if BUILD_PRESTO
+		&presto_interface,
+#endif
+#if BUILD_USBPROG == 1
+		&usbprog_interface,
+#endif
+#if BUILD_OPENJTAG == 1
+		&openjtag_interface,
+#endif
+#if BUILD_JLINK == 1
+		&jlink_interface,
+#endif
+#if BUILD_VSLLINK == 1
+		&vsllink_interface,
+#endif
+#if BUILD_RLINK == 1
+		&rlink_interface,
+#endif
+#if BUILD_ULINK == 1
+		&ulink_interface,
+#endif
+#if BUILD_ARMJTAGEW == 1
+		&armjtagew_interface,
+#endif
+#if BUILD_BUSPIRATE == 1
+		&buspirate_interface,
+#endif
+#if BUILD_REMOTE_BITBANG == 1
+		&remote_bitbang_interface,
+#endif
+#if BUILD_HLADAPTER == 1
+		&hl_interface,
+#endif
+#if BUILD_OSBDM == 1
+		&osbdm_interface,
+#endif
+#if BUILD_OPENDOUS == 1
+		&opendous_interface,
+#endif
+#if BUILD_SYSFSGPIO == 1
+		&sysfsgpio_interface,
+#endif
+#if BUILD_AICE == 1
+		&aice_interface,
+#endif
+#if BUILD_BCM2835GPIO == 1
+		&bcm2835gpio_interface,
+#endif
+#if BUILD_CMSIS_DAP == 1
+		&cmsis_dap_interface,
+#endif
+#if BUILD_KITPROG == 1
+		&kitprog_interface,
+#endif
+#if BUILD_IMX_GPIO == 1
+		&imx_gpio_interface,
+#endif
+#if BUILD_XDS110 == 1
+		&xds110_interface,
+#endif
+
+#if BUILD_LSCC_USB_CABLESERVER ==1
+		&lscc_cableserver_interface,
+#endif
+
+#endif /* standard drivers */
+		NULL,
+	};
+
+void jtag_interface_modules_load(const char *path)
+{
+	/* @todo: implement dynamic module loading for JTAG interface drivers */
+}
diff --git a/src/target/vexriscv.c b/src/target/vexriscv.c
index 9b3a378..772005d 100644
--- a/src/target/vexriscv.c
+++ b/src/target/vexriscv.c
@@ -15,12 +15,16 @@
 #include "vexriscv.h"
 
 #include <stdio.h>
+#ifdef _WIN32
+#include <winsock2.h>
+#else
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include <string.h>
 #include <arpa/inet.h>
-#include <fcntl.h>
 #include <netinet/tcp.h>
+#endif
+#include <string.h>
+#include <fcntl.h>
 #include <yaml.h>
 #include <errno.h>
 #include "algorithm.h"
@@ -882,7 +886,7 @@ static int vexriscv_network_read(struct vexriscv_common *vexriscv, void *buffer,
 		if (ret != sizeof(wb_buffer))
 			return 0;
 		memcpy(&intermediate, &wb_buffer[16], sizeof(intermediate));
-		intermediate = be32toh(intermediate);
+		intermediate = ntohl(intermediate);
 		memcpy(buffer, &intermediate, sizeof(intermediate));
 		return 4;
 	}
@@ -927,15 +931,15 @@ static int vexriscv_network_write(struct vexriscv_common *vexriscv, int is_read,
 
 		if (is_read) {
 			wb_buffer[11] = 1;	// Read count
-			data = htobe32(address);
+			data = htonl(address);
 			memcpy(&wb_buffer[16], &data, sizeof(data));
 		}
 		else {
 			wb_buffer[10] = 1;	// Write count
-			address = htobe32(address);
+			address = htonl(address);
 			memcpy(&wb_buffer[12], &address, sizeof(address));
 
-			data = htobe32(data);
+			data = htonl(data);
 			memcpy(&wb_buffer[16], &data, sizeof(data));
 		}
 		return write(vexriscv->clientSocket, wb_buffer, sizeof(wb_buffer));
diff --git a/tcl/interface/ftdi/digilent-hs2.cfg b/tcl/interface/ftdi/digilent-hs2.cfg
index 2005b66..d34c617 100644
--- a/tcl/interface/ftdi/digilent-hs2.cfg
+++ b/tcl/interface/ftdi/digilent-hs2.cfg
@@ -1,10 +1,36 @@
-# this supports JTAG-HS2 (and apparently Nexys4 as well)
-
-interface ftdi
-ftdi_device_desc "Digilent Adept USB Device"
-ftdi_vid_pid 0x0403 0x6014
-
-ftdi_channel 0
-ftdi_layout_init 0x00e8 0x60eb
-
-reset_config none
+# Digilent JTAG HS2 Adapter
+# Running in standard 4-wire JTAG mode (IEEE 1149.1)
+
+# https://reference.digilentinc.com/reference/programmers/jtag-hs2/start
+
+interface ftdi
+ftdi_device_desc "Digilent USB Device"
+ftdi_vid_pid 0x0403 0x6014
+
+ftdi_channel 0
+ftdi_layout_init 0x00e8 0x60eb
+
+# no TRST/SRST signal is available on the HS2 adapter
+reset_config none
+
+transport select jtag
+
+# Start with low (safe) speed.
+# The user can increase it later as needed.
+adapter_khz 4000
+
+
+
+
+
+
+# this supports JTAG-HS2 (and apparently Nexys4 as well)
+
+#interface ftdi
+#ftdi_device_desc "Digilent Adept USB Device"
+#ftdi_vid_pid 0x0403 0x6014
+
+#ftdi_channel 0
+#ftdi_layout_init 0x00e8 0x60eb
+
+#reset_config none
diff --git a/tcl/interface/lattice-usb-cableserver.cfg b/tcl/interface/lattice-usb-cableserver.cfg
new file mode 100644
index 0000000..5de6315
--- /dev/null
+++ b/tcl/interface/lattice-usb-cableserver.cfg
@@ -0,0 +1,12 @@
+#Lattice Driver interface
+
+interface lattice-usb-cableserver
+
+# no TRST/SRST signal is available on the Lattice adapter
+reset_config none
+
+transport select jtag
+
+# Start with low (safe) speed.
+# The user can increase it later as needed.
+adapter_khz 4000
\ No newline at end of file
diff --git a/tcl/target/vexriscv_sim.cfg b/tcl/target/vexriscv_sim.cfg
index 49874a9..59abc08 100644
--- a/tcl/target/vexriscv_sim.cfg
+++ b/tcl/target/vexriscv_sim.cfg
@@ -1,31 +1,32 @@
-interface dummy
-
-set  _ENDIAN little
-set _TAP_TYPE 1234
-
-if { [info exists CPUTAPID] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # set useful default
-   set _CPUTAPID 0x10001fff 
-}
-
-adapter_khz 4000
-adapter_nsrst_delay 260
-jtag_ntrst_delay 250
-
-set _CHIPNAME fpga_spinal
-jtag newtap $_CHIPNAME bridge -expected-id $_CPUTAPID -irlen 4 -ircapture 0x1 -irmask 0xF 
-
-target create $_CHIPNAME.cpu0 vexriscv -endian $_ENDIAN -chain-position $_CHIPNAME.bridge -coreid 0 -dbgbase 0xF00F0000
-vexriscv readWaitCycles 12
-vexriscv cpuConfigFile $VEXRISCV_YAML
-
-
-poll_period 50
-
-
-
-init
-#echo "Halting processor"
-soft_reset_halt
\ No newline at end of file
+interface dummy
+
+set  _ENDIAN little
+set _TAP_TYPE 1234
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # set useful default
+   set _CPUTAPID 0x10001fff 
+}
+
+adapter_khz 4000
+adapter_nsrst_delay 260
+jtag_ntrst_delay 250
+
+set _CHIPNAME fpga_spinal
+jtag newtap $_CHIPNAME bridge -expected-id $_CPUTAPID -irlen 4 -ircapture 0x1 -irmask 0xF 
+
+target create $_CHIPNAME.cpu0 vexriscv -endian $_ENDIAN -chain-position $_CHIPNAME.bridge -coreid 0 -dbgbase 0xF00F0000
+#target create $_CHIPNAME.cpu0 vexriscv -endian $_ENDIAN -chain-position $_CHIPNAME.bridge -coreid 0 -dbgbase 0x00000000
+vexriscv readWaitCycles 12
+vexriscv cpuConfigFile $VEXRISCV_YAML
+
+
+poll_period 50
+
+
+
+init
+#echo "Halting processor"
+#soft_reset_halt
-- 
1.9.1

