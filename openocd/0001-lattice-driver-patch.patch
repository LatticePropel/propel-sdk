From 05bb1d80ba572a71956f95c45fd1a7224a39a491 Mon Sep 17 00:00:00 2001
From: xli-lscc <xueping.li@latticesemi.com>
Date: Thu, 7 May 2020 15:56:04 +0800
Subject: [PATCH] lattice driver patch

---
 configure.ac                                       |    2 +
 src/jtag/drivers/Makefile.am                       |    4 +
 .../drivers/lattice_usb_cableserver/Makefile.am    |   11 +
 .../lattice_usb_cableserverclient.c                | 1244 ++++++++++++++++++++
 src/jtag/interfaces.c                              |    8 +
 tcl/interface/lattice-usb-cableserver.cfg          |   12 +
 tcl/target/riscv-small.cfg                         |   32 +
 7 files changed, 1313 insertions(+)
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/Makefile.am
 create mode 100644 src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
 create mode 100644 tcl/interface/lattice-usb-cableserver.cfg
 create mode 100644 tcl/target/riscv-small.cfg

diff --git a/configure.ac b/configure.ac
index d4338df..2e7f69f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -110,6 +110,7 @@ m4_define([ADAPTER_OPT], [m4_translit(ADAPTER_ARG($1), [_], [-])])
 
 m4_define([USB1_ADAPTERS],
 	[[[ftdi], [MPSSE mode of FTDI based devices], [FTDI]],
+	[[lscc_cableserver], [Lattice USB cableserver], [LSCC_USB_CABLESERVER]],
 	[[stlink], [ST-Link JTAG Programmer], [HLADAPTER_STLINK]],
 	[[ti_icdi], [TI ICDI JTAG Programmer], [HLADAPTER_ICDI]],
 	[[ulink], [Keil ULINK JTAG Programmer], [ULINK]],
@@ -706,6 +707,7 @@ AM_CONDITIONAL([IMX_GPIO], [test "x$build_imx_gpio" = "xyes"])
 AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
 AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes" -o "x$build_jtag_vpi" = "xyes"])
 AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
+AM_CONDITIONAL([LSCC_USB_CABLESERVER], [test "x$enable_lscc_usb_cableserver" != "xno"])
 AM_CONDITIONAL([AMTJTAGACCEL], [test "x$build_amtjtagaccel" = "xyes"])
 AM_CONDITIONAL([GW16012], [test "x$build_gw16012" = "xyes"])
 AM_CONDITIONAL([OOCD_TRACE], [test "x$build_oocd_trace" = "xyes"])
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 6fe40a6..e50dc6d 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -81,6 +81,10 @@ if USB_BLASTER_DRIVER
 %C%_libocdjtagdrivers_la_LIBADD += %D%/usb_blaster/libocdusbblaster.la
 include %D%/usb_blaster/Makefile.am
 endif
+if LSCC_USB_CABLESERVER
+%C%_libocdjtagdrivers_la_LIBADD += %D%/lattice_usb_cableserver/liblsccusbcableserver.la
+include %D%/lattice_usb_cableserver/Makefile.am
+endif
 if FT232R
 DRIVERFILES += %D%/ft232r.c
 endif
diff --git a/src/jtag/drivers/lattice_usb_cableserver/Makefile.am b/src/jtag/drivers/lattice_usb_cableserver/Makefile.am
new file mode 100644
index 0000000..35250ff
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES += %D%/liblsccusbcableserver.la
+%C%_liblsccusbcableserver_la_SOURCES = $(USB_CABLESERVER_SRC)
+%C%_liblsccusbcableserver_la_CPPFLAGS = -I$(top_srcdir)/src/jtag/drivers $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS) $(LIBFTDI_CFLAGS)
+
+USB_CABLESERVER_SRC = %D%/lattice_usb_cableserverclient.c %D%/lscc_cableserver_client.h
+
+if LSCC_USB_CABLESERVER
+USB_CABLESERVER_SRC += %D%/lattice_usb_cableserverclient.c
+endif
+
+liblsccusbcableserver_la_LIBADD = %D%/cableserver_client.lib
diff --git a/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c b/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
new file mode 100644
index 0000000..c8318b1
--- /dev/null
+++ b/src/jtag/drivers/lattice_usb_cableserver/lattice_usb_cableserverclient.c
@@ -0,0 +1,1244 @@
+/*   ==================================================================
+     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
+     ------------------------------------------------------------------
+     Copyright (c) 2006-2018 by Lattice Semiconductor Corporation
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+
+     ------------------------------------------------------------------
+
+     Lattice Semiconductor Corporation
+     111 SW Fifth Avenue, Suite 700
+     Portland, OR 97204
+     U.S.A
+
+     Email: techsupport@latticesemi.com
+     Web: http://www.latticesemi.com/Home/Support/SubmitSupportTicket.aspx
+     ================================================================== */
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include <usb.h>
+#include "helper/binarybuffer.h"
+#include "tlhelp32.h" 
+
+#define D_QueryCable 1
+#define D_QueryCablePort 2 
+#define D_CheckCable 3 
+#define D_SetCablePort 4 
+#define D_ScanDeviceChain 11 
+#define D_GetDeviceList 14 
+#define D_SetTargetDevice 15 
+#define D_GetDeviceID 16
+#define D_JumpState 18 
+#define D_Shift 19 
+#define D_ENDState 20
+#define D_LockCable 33 
+#define D_UnlockCable 34 
+#define D_ReleaseCablePort 35
+#define D_QueryCablewDescription 56
+#define D_DISCONNECT 9999
+
+#define jtagTEST_LOGIC_RESET 1
+#define jtagRUN_TEST_IDLE 2
+#define jtagPAUSEIR 3
+#define jtagPAUSEDR 4
+#define jtagSHIFTDR 5
+#define jtagSHIFTIR 6
+
+#define DAISY_CHAIN
+#define MAX_DEVICE_DAISY_CHAIN 10
+#define DC_TARGET_DEVICE 0
+#define DC_DEV_NUM 3
+
+#define BUFFER_DEFINED
+
+#define WR_BUFF_HEADER_LASTBIT 0x08
+#define WR_BUFF_HEADER_TDR_HDR 0x04
+#define WR_BUFF_HEADER_READ 0x02
+#define WR_BUFF_HEADER_WRITE 0x01
+#define WR_BUFF_HEADER_NA 0x00
+
+#define MAX_BUFFER_SIZE 65535
+
+typedef int (*client_connect_func)(void* client_handler, char* a_chrHostName, const char* a_chrFileName, const char* a_chrCableServerDir);
+typedef void* (*client_create_func)(char *client_name);
+typedef int (*client_send_func)(void* client_handler, int a_intCmd, ...);
+typedef int (*client_read_func)(void* client_handler,  char p_buffer[10][256],  unsigned int *dev_num);
+typedef int (*client_get_tdo_func)(void* client_handler, char* a_chrTDO, int a_intClock);
+typedef int (*client_get_tdo_unsigned_func)(void* client_handler, unsigned char* a_chrTDO, int a_intClock);
+
+enum ShiftModes
+{
+    SHI_IR = 0,
+    SHI_DR = 1
+};
+
+enum TdoModes
+{
+    TDO_NO = 0,
+    TDO_YES = 1
+};
+
+struct daisy_chain_device_ctx{
+	unsigned int num;  							
+	unsigned int target;  							
+	char dev_list[MAX_DEVICE_DAISY_CHAIN][256];  	
+};
+
+struct cableserver_client_ctx{
+	void *handle;
+	client_connect_func connect;
+	client_create_func create;
+	client_send_func send;
+	client_read_func read;
+	client_get_tdo_func get_tdo;
+	client_get_tdo_unsigned_func get_tdo_u;
+	uint8_t *in_value;
+	unsigned char *write_buffer;
+	unsigned char *read_buffer;
+	unsigned write_size;
+	unsigned read_size;
+	unsigned write_count;
+	unsigned read_count;
+};
+
+static struct cableserver_client_ctx *cableserver_client_ctx;
+static struct daisy_chain_device_ctx *daisy_chain_ctx;
+char *lattice_cable="USB2";
+char *lattice_port="FTUSB-0";
+char *lattice_host_name = "jtagadapter";
+
+/***************************************************************************/
+static void flip_array(unsigned char* send_data, unsigned w_header_bitlen){
+	unsigned char tmp=0x00;
+	for (int k=0; k<((w_header_bitlen+1)/2)/2; k++){
+		tmp=send_data[k];
+		send_data[k]=send_data[(w_header_bitlen+1)/2-1-k];
+		send_data[(w_header_bitlen+1)/2-1-k]=tmp;
+	}
+}
+
+static void extract_bridge_data(unsigned char * p_array, unsigned int bit_len, 
+		unsigned char* p_ret_array){
+	int i,j=0;
+	unsigned char tmp=0x00;
+	for (i=((bit_len+7)/8)/4-1, j=0; i>=0;i--,j++){
+		p_ret_array[i]=(p_array[j*4+0]&0x80)|((p_array[j*4+0]&0x08)<<3)
+			|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+			|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+			|((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3);
+	}
+
+	switch(bit_len%32){
+		case 0:
+			//covert 4Byte
+			tmp=(p_array[j*4+0]&0x80)|((p_array[j*4+0]&0x08)<<3)
+				|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+				|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+				|((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 4:
+			tmp|=(p_array[j*4+0]&0x08)>>3;
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 8:
+			tmp|=((p_array[j*4+0]&0x80)>>6)|((p_array[j*4+0]&0x08)>>3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 12:
+			tmp|=((p_array[j*4+1]&0x80)>>6)|((p_array[j*4+1]&0x08)>>3)
+				|((p_array[j*4+1]&0x08)>>1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 16:
+			tmp|=((p_array[j*4+1]&0x80)>>6)|((p_array[j*4+1]&0x08)>>3)
+				|((p_array[j*4+0]&0x80)>>4)|((p_array[j*4+0]&0x08)>>1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 20:
+			tmp|=((p_array[j*4+2]&0x80)>>6)|((p_array[j*4+2]&0x08)>>3)
+				|((p_array[j*4+1]&0x80)>>4)|((p_array[j*4+1]&0x08)>>1)
+				|(((p_array[j*4+0]&0x08))<<1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 24:
+			tmp|=((p_array[j*4+2]&0x80)>>6)|((p_array[j*4+2]&0x08)>>3)
+				|((p_array[j*4+1]&0x80)>>4)|((p_array[j*4+1]&0x08)>>1)
+				|((p_array[j*4+0]&0x80)>>2)|((p_array[j*4+0]&0x08)<<1);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		case 28:
+			tmp|=((p_array[j*4+3]&0x80)>>6)|((p_array[j*4+3]&0x08)>>3)
+				|((p_array[j*4+2]&0x80)>>4)|((p_array[j*4+2]&0x08)>>1)
+				|((p_array[j*4+1]&0x80)>>2)|((p_array[j*4+1]&0x08)<<1)
+				|((p_array[j*4+0]&0x08)<<3);
+			p_ret_array[((bit_len+7)/8)/4]=tmp;
+			break;
+		default:
+			break;
+		
+	}
+}
+
+unsigned add_header(unsigned char *send_data, unsigned bit_send_len){
+	unsigned trailer_len=daisy_chain_ctx->num-1-daisy_chain_ctx->target;
+	unsigned char *trailer_data=NULL;
+	trailer_data=calloc((trailer_len*4+7)/8,sizeof(unsigned char));
+	memset(trailer_data, 0x33, (trailer_len*4+7)/8);
+	bit_copy(send_data,  bit_send_len*4, trailer_data, 0, trailer_len*4);
+	free(trailer_data);
+	return bit_send_len+trailer_len;
+}
+
+unsigned add_trailer(unsigned char *send_data, unsigned bit_send_len){
+	unsigned header_len=daisy_chain_ctx->num-1-daisy_chain_ctx->target;
+	unsigned char header_data[MAX_BUFFER_SIZE]={0};
+	memset(header_data, 0x33, (header_len*4+7)/8);
+	bit_copy(header_data,  header_len*4, send_data, 0, bit_send_len*4);
+	memcpy(send_data, header_data, ((bit_send_len+header_len)*4+7)/8);
+	return (bit_send_len+header_len);
+}
+
+static unsigned cableserver_buffer_read_space(void){
+	return cableserver_client_ctx->read_size - cableserver_client_ctx->read_count;
+}
+
+static unsigned cableserver_buffer_write_space(void){
+	/* Reserve one byte for SEND_IMMEDIATE */
+	return cableserver_client_ctx->write_size - cableserver_client_ctx->write_count - 1;
+}
+
+static void cableserver_buffer_write_byte(uint8_t data){
+	assert(cableserver_client_ctx->write_count < cableserver_client_ctx->write_size);
+	cableserver_client_ctx->write_buffer[cableserver_client_ctx->write_count++] = data;
+}
+
+static int cableserver_buffer_flush(void){
+	uint8_t w_header_flag=0;
+	unsigned w_header_bitlen=0;
+
+	unsigned i=0;
+	unsigned char send_data[MAX_BUFFER_SIZE]={0};
+	unsigned char received_data[MAX_BUFFER_SIZE]={0};
+	unsigned char received_data_test[MAX_BUFFER_SIZE]={0};
+	bool get_tdo_done=false;
+	unsigned m=0;
+	unsigned last_byte_bit_offset=0;
+	unsigned bit_len_to_send=0;
+
+	while(i<cableserver_client_ctx->write_count){
+		w_header_flag=cableserver_client_ctx->write_buffer[i];
+		w_header_bitlen=cableserver_client_ctx->write_buffer[i+2];
+		w_header_bitlen=(w_header_bitlen<<8)&0xFF00;
+		w_header_bitlen|=cableserver_client_ctx->write_buffer[i+1];
+
+		if(w_header_bitlen==0)
+			break;
+		
+		if((w_header_flag&WR_BUFF_HEADER_WRITE)==WR_BUFF_HEADER_WRITE){	
+			if((w_header_flag&WR_BUFF_HEADER_READ)!=WR_BUFF_HEADER_READ){
+				bit_copy(&send_data[m], last_byte_bit_offset, &(cableserver_client_ctx->write_buffer[i+3]), 0, w_header_bitlen*4);
+				bit_len_to_send+=w_header_bitlen;
+				if ((bit_len_to_send%2)==1){
+					last_byte_bit_offset=4;
+					m=(bit_len_to_send+1)/2-1;
+				}else{
+					last_byte_bit_offset=0;
+					m=(bit_len_to_send+1)/2;
+				}
+				i+=(3+(w_header_bitlen+1)/2); 
+			}else{ //before read cmd, send the write cmd, if there are
+				if(bit_len_to_send>0){
+					flip_array(send_data, bit_len_to_send);
+					cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4, TDO_NO, send_data);
+				}
+				bit_len_to_send=0;
+				
+				//reset parameters, only can have one read cmd, since, when we meet read cmd, we will send it immediately
+				m=0;
+				bit_copy(&send_data[m], 0, &(cableserver_client_ctx->write_buffer[i+3]), 0, w_header_bitlen*4);
+				flip_array(send_data, w_header_bitlen);
+				cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, w_header_bitlen*4, TDO_YES, send_data);
+				cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, received_data, w_header_bitlen*4);
+
+				uint8_t tmp_data=0;
+				unsigned trailer_bit_len=daisy_chain_ctx->num-1-daisy_chain_ctx->target;
+
+				for (int lo_i=0; lo_i<(w_header_bitlen*4+7)/8; lo_i++){
+					received_data_test[lo_i]=received_data[lo_i]>>trailer_bit_len;
+					received_data_test[lo_i]&=(0xFF>>trailer_bit_len); //clear to 0,  hight 2 bit
+					received_data_test[lo_i]|=(tmp_data&(0xFF>>(8-trailer_bit_len)))<<(8-trailer_bit_len);
+					tmp_data=received_data[lo_i];
+				}
+				memcpy(received_data, &received_data_test[0], ((w_header_bitlen*4+7)/8)*sizeof(unsigned char));
+				i+=(3+(w_header_bitlen+1)/2); 
+				get_tdo_done=true;
+			}
+		}
+	}
+
+	if(bit_len_to_send>0){
+		flip_array(send_data, bit_len_to_send);
+		cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, bit_len_to_send*4, TDO_NO, send_data);
+		bit_len_to_send=0;	
+	}
+	
+	if (get_tdo_done){
+		get_tdo_done=false;
+		unsigned r_bit_offset=0;
+		unsigned r_bit_len=0;
+		r_bit_offset=cableserver_client_ctx->read_buffer[1];
+		r_bit_offset=(r_bit_offset<<8)&0xFF00;
+		r_bit_offset|=cableserver_client_ctx->read_buffer[0];
+		r_bit_len=cableserver_client_ctx->read_buffer[3];
+		r_bit_len=(r_bit_len<<8)&0xFF00;
+		r_bit_len|=cableserver_client_ctx->read_buffer[2];  //not correct
+				
+		if((w_header_flag&WR_BUFF_HEADER_LASTBIT)!=WR_BUFF_HEADER_LASTBIT){
+			unsigned gap=w_header_bitlen-r_bit_len;
+			extract_bridge_data((unsigned char *)(&received_data[(gap*4+7)/8]), r_bit_len*4, received_data_test);  //there is a bug for out_offset, only when received multi fields
+			bit_copy(cableserver_client_ctx->in_value, 0, received_data_test, 0, r_bit_len);
+		}else{
+			cableserver_client_ctx->in_value[(r_bit_offset+7)/8-1]|=((received_data[0]&0x08)>>3)<<(r_bit_offset%8);
+		}
+	}
+
+	memset(cableserver_client_ctx->write_buffer, 0, sizeof(unsigned char)*(cableserver_client_ctx->write_size));
+	memset(cableserver_client_ctx->read_buffer, 0, sizeof(unsigned char)*(cableserver_client_ctx->read_size));
+	cableserver_client_ctx->write_count=0;
+	cableserver_client_ctx->read_count=0;
+	return 0;
+	
+}
+
+static unsigned cableserver_buffer_write(const uint8_t *out, unsigned out_offset, unsigned bit_count){
+	memcpy(&(cableserver_client_ctx->write_buffer[cableserver_client_ctx->write_count]), &(out[out_offset/8]), bit_count/8);
+	cableserver_client_ctx->write_count+=bit_count/8;
+	return 0;
+}
+static unsigned  cableserver_buffer_add_read(uint8_t *in,  unsigned in_offset, unsigned bit_count){
+	//[0-1]:bit_offset, [2-3]:bit_count
+	cableserver_client_ctx->in_value=in;
+	cableserver_client_ctx->read_buffer[0]=(in_offset&0xFF);
+	cableserver_client_ctx->read_buffer[1]=(in_offset&0xFF00)>>8;
+	cableserver_client_ctx->read_buffer[2]=(bit_count&0xFF);
+	cableserver_client_ctx->read_buffer[3]=(bit_count&0xFF00)>>8;
+	return bit_count;
+}
+
+
+void cableserver_clock_tms_cs(const uint8_t *out, unsigned out_offset, 
+		uint8_t *in, unsigned in_offset, unsigned length, bool tdi, bool last_bit){
+	//header: 1byte:r/w flag, 2bytes: package length(half byte as length), total,header length=3, bit length*4=byte length, every 1bit=>4bits
+	//byte: 01 write, 02 write/read, 03 read(actually, need to write to shit out data),00:null, read buffer header only have 2 bytes to descripes the length
+	
+	/* Guarantee buffer space enough for a minimum size transfer */
+	if(cableserver_buffer_write_space()<(((length+1)/2)+3) ||(in&&cableserver_buffer_read_space()<(((length+1)/2)+4))){
+		cableserver_buffer_flush();
+	}
+
+	if (length>0){
+		if(((length+1)/2+3)>MAX_BUFFER_SIZE){
+			LOG_ERROR("ERROR::  cableserver buffer overflow!");
+			return;
+		}
+		uint8_t header_flag=WR_BUFF_HEADER_WRITE;
+		header_flag |= last_bit ? WR_BUFF_HEADER_LASTBIT : WR_BUFF_HEADER_NA;
+		header_flag |= in ? WR_BUFF_HEADER_READ : WR_BUFF_HEADER_NA;
+		cableserver_buffer_write_byte(header_flag);  //0x02:r/w, 0x01:w
+		cableserver_buffer_write_byte(length&0xFF);  //data length. hal byte unit=bit_len
+		cableserver_buffer_write_byte((length&0xFF00)>>8);
+	}
+	
+	while(length>0){
+		//byte transfer
+		unsigned this_bits=length;
+		unsigned out_data=*out;
+		if (this_bits>7)
+			this_bits=7;
+		
+		if (this_bits>0){
+			length-=this_bits;
+			unsigned char tmp=0x01; //always the last bit: 1 valid
+			uint8_t data_out=0x00;
+			switch(this_bits%8){
+				case 0:
+					LOG_ERROR("TMS len=0 for JTAG state machine error");
+					break;
+				case 1:
+					data_out=((out_data&0x01)<<2)|tmp;
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 2:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 3:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 4:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 5:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4);
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4);
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 6:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp);
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				case 7:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp); 
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x40)>>4)|(tmp);
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x02 : 0x00));
+					break;
+				case 8:
+					data_out=((out_data&0x01)<<2)|tmp;
+					data_out|=((out_data&0x02)<<5)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x04))|(tmp); 
+					data_out|=((out_data&0x08)<<3)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x10)>>2)|(tmp);
+					data_out|=((out_data&0x20)<<1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out);
+					data_out=((out_data&0x40)>>4)|(tmp); 
+					data_out|=((out_data&0x80)>>1)|(tmp<<4); 
+					cableserver_buffer_write_byte(data_out|(tdi ? 0x20 : 0x00));
+					break;
+				default:
+					LOG_ERROR("LSCC:: TMS len>8 for JTAG state machine error");
+					break;
+	
+			}
+			if(in) {//send immediately
+				cableserver_buffer_add_read(in, in_offset, 1);
+				cableserver_buffer_flush();
+			}
+		}	
+	}
+}
+
+void cableserver_clock_tms_cs_out(const uint8_t *out, unsigned out_offset, 
+		unsigned length, bool tdi){
+	cableserver_clock_tms_cs(out, out_offset, NULL, 0, length, tdi, false);
+}
+
+void cableserver_clock_data(const uint8_t *out, unsigned out_offset, uint8_t *in, 
+		unsigned in_offset, unsigned length, unsigned in_bit_len){
+	unsigned tmp_offset=0;
+	//unsigned local_len=length;
+	/* Guarantee buffer space enough for a minimum size transfer */
+	if(cableserver_buffer_write_space()<(((length+1)/2)+3) ||
+		(in&&cableserver_buffer_read_space()<(((length+1)/2)+4)))
+		cableserver_buffer_flush();
+
+	//add header
+	if (length>0){
+		if(((length+1)/2+3)>MAX_BUFFER_SIZE){
+			LOG_ERROR("ERROR::  cableserver buffer overflow!\n");
+			return;
+		}
+		
+		uint8_t header_flag=WR_BUFF_HEADER_WRITE;
+		header_flag |= in ? WR_BUFF_HEADER_READ : WR_BUFF_HEADER_NA;
+		
+		cableserver_buffer_write_byte( header_flag);  //0x02:r/w, 0x01:w
+		cableserver_buffer_write_byte(length&0xFF);  //data length. hal byte unit=bit_len
+		cableserver_buffer_write_byte((length&0xFF00)>>8);
+	}
+	
+	while(length>0){//bitlen
+		if(length<8){
+			unsigned char tmp=0x01;
+			unsigned char *out_buff=NULL;
+			out_buff=(unsigned char *)malloc(sizeof(unsigned char)*((length+1)/2));
+			memset(out_buff, 0, sizeof(unsigned char)*((length+1)/2));
+			
+			if(out){
+				 //send last byte
+				switch(length){
+					case 0:
+						break;
+					case 1:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4 bits
+						break;
+					case 2:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						break;
+					case 3:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp); //low 4bits
+						break;
+					case 4:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp); //low 4bits
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4); //high 4bits
+						break;
+					case 5:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp); //low 4bits
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4); //high 4bits
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp); //low 4bits
+						break;
+					case 6:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp); //low 4bits
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4); //high 4bits
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp); //low 4bits
+						out_buff[2]|=((out[tmp_offset]&0x20))|(tmp<<4); //high 4bits
+						break;
+					case 7:
+						out_buff[0]=((out[tmp_offset]&0x01)<<1)|tmp;//low 4bits
+						out_buff[0]|=((out[tmp_offset]&0x02)<<4)|(tmp<<4); //high 4bits
+						out_buff[1]=((out[tmp_offset]&0x04)>>1)|(tmp); //low 4bits
+						out_buff[1]|=((out[tmp_offset]&0x08)<<2)|(tmp<<4); //high 4bits
+						out_buff[2]=((out[tmp_offset]&0x10)>>3)|(tmp); //low 4bits
+						out_buff[2]|=((out[tmp_offset]&0x20))|(tmp<<4); //high 4bits
+						out_buff[3]=((out[tmp_offset]&0x40)>>5)|(tmp); //low 4bits
+						break;
+					default:
+						LOG_ERROR("TMS len>8 for JTAG state machine error\n");
+						break;
+				}
+				cableserver_buffer_write(out_buff, 0, ((length+1)/2)*8);
+			}
+			
+			if(in){
+				if(!out){
+					memset(out_buff, 0x33, sizeof(unsigned char)*((length+1)/2));
+					cableserver_buffer_write(out_buff, 0, ((length+1)/2)*8);
+				}
+				cableserver_buffer_add_read(in, in_offset, in_bit_len);
+			}
+			
+			if(!out && !in){
+				memset(out_buff, 0x33, sizeof(unsigned char)*((length+1)/2));
+				cableserver_buffer_write(out_buff, 0,  ((length+1)/2)*8);
+			}
+				
+			length=0;
+			free(out_buff);
+			
+		}else{
+			unsigned this_bytes=length/8;
+			tmp_offset+=this_bytes;
+			if(this_bytes*8+3>MAX_BUFFER_SIZE)
+				this_bytes=MAX_BUFFER_SIZE; 	
+
+			if(this_bytes>0){
+				if(out){
+					//before call buffer write, need to convert data to bridge data
+					unsigned char *out_buff=NULL;
+					unsigned char tmp=0x01;
+					out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+					memset(out_buff, 0, sizeof(unsigned char)*(this_bytes*4));
+					
+					for(int i=0; i<this_bytes; i++){
+						out_buff[i*4+0]=((out[out_offset+i]&0x01)<<1)|tmp;			
+						out_buff[i*4+0]|=((out[out_offset+i]&0x02)<<4)|(tmp<<4); 	
+						out_buff[i*4+1]=((out[out_offset+i]&0x04)>>1)|(tmp); 		
+						out_buff[i*4+1]|=((out[out_offset+i]&0x08)<<2)|(tmp<<4); 	
+						out_buff[i*4+2]=((out[out_offset+i]&0x10)>>3)|(tmp); 		
+						out_buff[i*4+2]|=((out[out_offset+i]&0x20))|(tmp<<4); 		
+						out_buff[i*4+3]=((out[out_offset+i]&0x40)>>5)|(tmp); 		
+						out_buff[i*4+3]|=((out[out_offset+i]&0x80)>>2)|(tmp<<4); 	
+					}
+					cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+					free(out_buff);
+				}
+
+				if(in){
+					if(!out){
+						unsigned char *out_buff=NULL;
+						out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+						memset(out_buff, 0x33, sizeof(unsigned char)*(this_bytes*4));
+						
+						cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+						free(out_buff);
+					}
+
+					in_offset+=cableserver_buffer_add_read(in, in_offset, in_bit_len);
+				}
+				if(!out && !in){
+					unsigned char *out_buff=NULL;
+					out_buff=(unsigned char *)malloc(sizeof(unsigned char)*(this_bytes*4));
+					memset(out_buff, 0x33, sizeof(unsigned char)*(this_bytes*4));
+					
+					cableserver_buffer_write(out_buff, 0, this_bytes*8*4);
+					free(out_buff);
+				}
+				length-=this_bytes*8;
+			}
+		}
+	}
+	if(in){
+		cableserver_buffer_flush();
+	}
+}
+
+static void cableserver_tap_set_end_state(tap_state_t state){
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
+	else {
+		LOG_ERROR("BUG: %s is not a stable end state", tap_state_name(state));
+		exit(-1);
+	}
+}
+
+static void cableserver_tap_move_to_state(tap_state_t goal_state){
+	tap_state_t start_state = tap_get_state();
+
+	/*	goal_state is 1/2 of a tuple/pair of states which allow convenient
+		lookup of the required TMS pattern to move to this state from the
+		start state.
+	*/
+
+	/* do the 2 lookups */
+	uint8_t tms_bits  = tap_get_tms_path(start_state, goal_state);
+	int tms_count = tap_get_tms_path_len(start_state, goal_state);
+	assert(tms_count <= 8);
+
+	DEBUG_JTAG_IO("start=%s goal=%s\n", tap_state_name(start_state), tap_state_name(goal_state));
+
+	/* Track state transitions step by step */
+	for (int i = 0; i < tms_count; i++)
+		tap_set_state(tap_state_transition(tap_get_state(), (tms_bits >> i) & 1));
+	
+	cableserver_clock_tms_cs_out(&tms_bits, 0, tms_count, false);
+}
+
+static void cableserver_execute_scan(struct jtag_command *cmd){
+	static bool first_run=true;
+	DEBUG_JTAG_IO("%s type:%d\n", cmd->cmd.scan->ir_scan ? "IRSCAN" : "DRSCAN", 
+		jtag_scan_type(cmd->cmd.scan));
+
+	/* Make sure there are no trailing fields with num_bits == 0, or the logic below will fail. */
+	while (cmd->cmd.scan->num_fields > 0
+			&& cmd->cmd.scan->fields[cmd->cmd.scan->num_fields - 1].num_bits == 0) {
+		cmd->cmd.scan->num_fields--;
+		DEBUG_JTAG_IO("discarding trailing empty field");
+	}
+
+	if (cmd->cmd.scan->num_fields == 0) {
+		DEBUG_JTAG_IO("empty scan, doing nothing");
+		return;
+	}
+
+	if (cmd->cmd.scan->ir_scan) {
+		if (tap_get_state() != TAP_IRSHIFT)
+			cableserver_tap_move_to_state(TAP_IRSHIFT);
+	} else {
+		if (tap_get_state() != TAP_DRSHIFT)
+			cableserver_tap_move_to_state(TAP_DRSHIFT);
+	}
+
+	cableserver_tap_set_end_state(cmd->cmd.scan->end_state);
+
+	struct scan_field *field = cmd->cmd.scan->fields;
+	unsigned scan_size = 0;
+	uint8_t *out_value=NULL;
+	uint8_t *in_value=NULL;
+
+	for (int i = 0; i < cmd->cmd.scan->num_fields; i++, field++) {
+		scan_size += field->num_bits;
+		DEBUG_JTAG_IO("%s%s field %d/%d %d bits",
+			field->in_value ? "in" : "", 
+			field->out_value ? "out" : "", 
+			i, 
+			cmd->cmd.scan->num_fields, 
+			field->num_bits);
+
+		if (field->in_value){
+			in_value=calloc((field->num_bits*3+7)/8, sizeof(uint8_t));
+			bit_copy(in_value, 0, field->in_value, 0, field->num_bits);
+			bit_copy(in_value, field->num_bits, field->in_value, 0, field->num_bits);
+			bit_copy(in_value, field->num_bits*2, field->in_value, 0, field->num_bits);
+		}
+
+		if (field->out_value){
+			out_value=calloc((field->num_bits*3+7)/8, sizeof(uint8_t));
+			bit_copy(out_value, 0, field->out_value, 0, field->num_bits);
+			bit_copy(out_value, field->num_bits, field->out_value, 0, field->num_bits);
+			bit_copy(out_value, field->num_bits*2, field->out_value, 0, field->num_bits);
+		}
+
+		if (first_run){
+			first_run=false;
+			cableserver_tap_move_to_state(TAP_RESET);  //rest to init tap id
+			cableserver_tap_move_to_state(TAP_IRSHIFT); //move to ir shift
+			unsigned char id_cmd[1]={0x01}; 				//switch to ID channel, bit_len is 4, first send 3 bit
+			cableserver_clock_data(id_cmd, 0, NULL, 0, 3, 0);
+			cableserver_tap_move_to_state(TAP_DRSHIFT);
+		}
+
+		if (i == cmd->cmd.scan->num_fields - 1 && tap_get_state() != tap_get_end_state()) {
+			/* Last field, and we're leaving IRSHIFT/DRSHIFT. Clock last bit during tap
+			 * movement. This last field can't have length zero, it was checked above. */
+			if (!(field->out_value) && !(field->in_value)&&(field->num_bits>0)){
+
+				uint8_t last_bit = 0;
+				uint8_t tmsbit=0x01;
+				cableserver_clock_data(NULL, 0, NULL, 0,  field->num_bits-1, 0);
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, (last_bit==0x01) ? true : false, true);
+				
+				//set to idle
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+				tmsbit=0x00;
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+				tap_set_state(TAP_IDLE);
+			}
+			
+			if(field->in_value){
+				if(!(field->out_value)){
+					uint8_t last_bit = 1;
+					uint8_t tmsbit=0x01;
+					cableserver_clock_data(in_value, 0, field->in_value, 0,  field->num_bits*3-1, field->num_bits-1);
+					cableserver_clock_tms_cs(&tmsbit, 0, field->in_value, field->num_bits*3-1, 1, (last_bit==0x01) ?  true : false, true);
+					
+					//set to idle
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tmsbit=0x00;
+					cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+					tap_set_state(TAP_IDLE);			
+				}
+			}
+			
+			if (field->out_value){
+				uint8_t last_bit = 0;
+				uint8_t tmsbit=0x01;
+				cableserver_clock_data(out_value, 0, field->in_value, 0,  field->num_bits*3-1, field->num_bits-1);
+				last_bit=((out_value[(field->num_bits*3+7)/8-1])>>((((field->num_bits*3)%8-1)>0) ? ((field->num_bits*3)%8-1) : 0))&0x01;		
+				cableserver_clock_tms_cs(&tmsbit, 0, field->in_value, field->num_bits*3-1, 1, (last_bit==0x01) ? true: false, true);
+
+				//set to idle
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+				tmsbit=0x00;
+				cableserver_clock_tms_cs(&tmsbit, 0, NULL, 0, 1, false, false);
+				tap_set_state(TAP_IDLE);	
+			}
+		} else{
+
+			if (!(field->out_value) && !(field->in_value) &&(field->num_bits>0))
+				cableserver_clock_data(NULL, 0, NULL, 0,  field->num_bits, 0);
+			
+			if(field->in_value){
+				if(!(field->out_value))
+					cableserver_clock_data(in_value, 0, field->in_value, 0,  field->num_bits*3, field->num_bits);
+			}
+			
+			if (field->out_value)
+				cableserver_clock_data(out_value, 0, field->in_value, 0,  field->num_bits*3, field->num_bits);
+		}		
+	}
+
+	if (tap_get_state() != tap_get_end_state())
+		 cableserver_tap_move_to_state(tap_get_end_state());
+
+	DEBUG_JTAG_IO("%s scan, %i bits, end in %s",(cmd->cmd.scan->ir_scan) ? "IR" : "DR",
+		scan_size,tap_state_name(tap_get_end_state()));
+}
+
+static void cableserver_execute_pathmove(struct jtag_command *cmd){
+	tap_state_t *path = cmd->cmd.pathmove->path;
+	int num_states  = cmd->cmd.pathmove->num_states;
+
+	DEBUG_JTAG_IO("pathmove: %i states, current: %s  end: %s", 
+		num_states,
+		tap_state_name(tap_get_state()),
+		tap_state_name(path[num_states-1]));
+
+	int state_count = 0;
+	unsigned bit_count = 0;
+	uint8_t tms_byte = 0;
+
+
+	/* this loop verifies that the path is legal and logs each state in the path */
+	while (num_states--) {
+
+		/* either TMS=0 or TMS=1 must work ... */
+		if (tap_state_transition(tap_get_state(), false) 
+			== path[state_count])
+			buf_set_u32(&tms_byte, bit_count++, 1, 0x0);
+		else if (tap_state_transition(tap_get_state(), true) 
+			== path[state_count]) {
+			buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
+
+			/* ... or else the caller goofed BADLY */
+		} else {
+			LOG_ERROR("BUG: %s -> %s isn't a valid "
+				"TAP state transition",
+				tap_state_name(tap_get_state()),
+				tap_state_name(path[state_count]));
+			exit(-1);
+		}
+
+		tap_set_state(path[state_count]);
+		state_count++;
+
+		if (bit_count == 7 || num_states == 0) {
+			cableserver_clock_tms_cs_out(&tms_byte, 0, bit_count, false);
+			bit_count = 0;
+		}
+	}
+	tap_set_end_state(tap_get_state());
+}
+
+static void cableserver_execute_statemove(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("statemove end in %s",
+		tap_state_name(cmd->cmd.statemove->end_state));
+
+	cableserver_tap_set_end_state(cmd->cmd.statemove->end_state);
+
+	/* shortest-path move to desired end state */
+	if (tap_get_state() != tap_get_end_state() ||
+		tap_get_end_state() == TAP_RESET)
+		 cableserver_tap_move_to_state(tap_get_end_state());
+}
+
+static void cableserver_execute_stableclocks(struct jtag_command *cmd){
+	/* this is only allowed while in a stable state.  A check for a stable
+	 * state was done in jtag_add_clocks()
+	 */
+	int num_cycles = cmd->cmd.stableclocks->num_cycles;
+	/* 7 bits of either ones or zeros. */
+	uint8_t tms = tap_get_state() == TAP_RESET ? 0x7f : 0x00;
+	
+
+	/* TODO: Use mpsse_clock_data with in=out=0 for this, if TMS can be set to
+	 * the correct level and remain there during the scan */
+	while (num_cycles > 0) {
+		unsigned this_len = num_cycles > 7 ? 7 : num_cycles;
+		cableserver_clock_tms_cs_out(&tms, 0, this_len, false);
+		/* there are no state transitions in this code, so omit state tracking */
+		num_cycles -= this_len;
+	}
+
+	DEBUG_JTAG_IO("clocks %i while in %s",
+		cmd->cmd.stableclocks->num_cycles,
+		tap_state_name(tap_get_state()));
+
+}
+
+static void cableserver_execute_runtest(struct jtag_command *cmd){
+	int i;
+	uint8_t zero = 0;
+
+	DEBUG_JTAG_IO("runtest %i cycles, end in %s",
+		cmd->cmd.runtest->num_cycles,
+		tap_state_name(cmd->cmd.runtest->end_state));
+
+	if (tap_get_state() != TAP_IDLE)
+		 cableserver_tap_move_to_state(TAP_IDLE);
+
+	/* TODO: Reuse ftdi_execute_stableclocks */
+	i = cmd->cmd.runtest->num_cycles;
+	while (i > 0) {
+		/* there are no state transitions in this code, so omit state tracking */
+		unsigned this_len = i > 7 ? 7 : i;
+		cableserver_clock_tms_cs_out(&zero, 0, this_len, false);
+		i -= this_len;
+	}
+	cableserver_tap_set_end_state(cmd->cmd.runtest->end_state);
+
+	if (tap_get_state() != tap_get_end_state())
+		 cableserver_tap_move_to_state(tap_get_end_state());
+
+	DEBUG_JTAG_IO("runtest: %i, end in %s",
+		cmd->cmd.runtest->num_cycles,
+		tap_state_name(tap_get_end_state()));
+}
+
+static void cableserver_execute_reset(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("reset trst: %i srst %i\n",
+		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+
+	if (cmd->cmd.reset->trst == 1
+	    || (cmd->cmd.reset->srst
+		&& (jtag_get_reset_config() & RESET_SRST_PULLS_TRST))){
+		tap_set_state(TAP_RESET);
+	}
+	 cableserver_tap_move_to_state(TAP_RESET);
+
+	DEBUG_JTAG_IO("trst: %i, srst: %i",
+		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+}
+
+static void cableserver_execute_sleep(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("sleep %" PRIi32, cmd->cmd.sleep->us);
+	jtag_sleep(cmd->cmd.sleep->us);
+	DEBUG_JTAG_IO("sleep %" PRIi32 " usec while in %s",
+		cmd->cmd.sleep->us,
+		tap_state_name(tap_get_state()));
+}
+
+static void cableserver_execute_tms(struct jtag_command *cmd){
+	DEBUG_JTAG_IO("TMS: %d bits", cmd->cmd.tms->num_bits);
+}
+
+static void cableserver_execute_command(struct jtag_command *cmd){
+	switch (cmd->type) {
+			case JTAG_RESET:
+				cableserver_execute_reset(cmd);
+				break;
+			case JTAG_RUNTEST:
+				cableserver_execute_runtest(cmd);
+				break;
+			case JTAG_STABLECLOCKS:
+				cableserver_execute_stableclocks(cmd);
+				break;
+			case JTAG_TLR_RESET:
+				cableserver_execute_statemove(cmd);
+				break;
+			case JTAG_PATHMOVE:
+				cableserver_execute_pathmove(cmd);
+				break;
+			case JTAG_TMS:
+				cableserver_execute_tms(cmd);  
+				break;
+			case JTAG_SLEEP:
+				cableserver_execute_sleep(cmd); 
+				break;
+			case JTAG_SCAN:
+				cableserver_execute_scan(cmd);
+				break;
+			default:
+				break;	
+		}
+}
+
+static void cableserver_close(char *cable, char *port){
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_UnlockCable)!=0){
+		LOG_ERROR("lock cable failed\n");
+		return;
+	}
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_ReleaseCablePort, cable, port, 0) !=0){
+		LOG_ERROR("LSCC::release cable port failed\n");
+		return;
+	}
+}
+
+struct cableserver_client_ctx *cableserver_open(void){
+	HINSTANCE handler_dll = NULL;
+	
+	struct cableserver_client_ctx *ctx=calloc(1, sizeof(*ctx));
+	if(!ctx)
+		return 0;
+
+	char str[1024+256];  //path+name
+	memset(str, '\0', 1024+256);
+   	GetModuleFileNameA(NULL, str, 1024); //openOCD.exe path, include name
+   	strrchr(str, '\\')[1]=0;  //remove openOCD.exe name
+	char *path=strrchr(str, '\\')+1;
+
+	strcpy(path, "cableserver_client.dll");
+	handler_dll = LoadLibrary(str);
+	if (handler_dll==NULL){
+		LOG_ERROR("load lib failed\n");
+		return NULL;
+	}
+
+	//set enviroment
+	strrchr(str, '\\')[1]=0;  //remove openOCD.exe name
+	path=strrchr(str, '\\')+1;
+	strcpy(path, "..\\..\\ispFPGA");
+	char foundry_path[1024+512]="FOUNDRY=";
+	strcpy(foundry_path+8, str);
+   	_putenv(foundry_path);
+
+	ctx->read_size=MAX_BUFFER_SIZE;
+	ctx->write_size=MAX_BUFFER_SIZE;
+	ctx->read_buffer=calloc(1, ctx->read_size);
+	ctx->write_buffer=calloc(1, ctx->write_size);
+	ctx->write_count=0;
+	ctx->read_count=0;
+	ctx->create=(client_create_func)GetProcAddress(handler_dll, "ClientCreate");
+	ctx->connect=(client_connect_func)GetProcAddress(handler_dll, "ClientConnect");
+	ctx->send=(client_send_func)GetProcAddress(handler_dll, "ClientSend");
+	ctx->read=(client_read_func)GetProcAddress(handler_dll, "ClientRead");
+	ctx->get_tdo=(client_get_tdo_func)GetProcAddress(handler_dll, "ClientGetTDO");
+	ctx->get_tdo_u= (client_get_tdo_unsigned_func)GetProcAddress(handler_dll, "ClientGetTDO_U");
+
+	return ctx;
+}
+
+int cableserver_config(void){
+	unsigned char er1_data[1]={0x32};  
+	unsigned char select_channel[3]={0x00,0x00,0x16}; //selectTCRInstr, ecpENABLE, 21bit
+	unsigned char er2_data[1]={0x38};
+	unsigned char enable_nop[1]={0x00};
+	char dev_buff[10][256]; //cable list, device list
+	int dev_num;
+	int status;
+	unsigned char *cmd_data; 
+	
+	daisy_chain_ctx=calloc(1, sizeof(struct daisy_chain_device_ctx));
+	daisy_chain_ctx->num=DC_DEV_NUM;
+	daisy_chain_ctx->target=DC_TARGET_DEVICE;
+
+	//create, connect cable
+	cableserver_client_ctx->handle=cableserver_client_ctx->create(lattice_host_name);
+	if (cableserver_client_ctx->handle==NULL){
+		LOG_ERROR("Error:: client create failed\n");
+		return ERROR_FAIL;
+	}
+	//connect to cableserver,  create cableserver process to listen TCP/IP
+	if (cableserver_client_ctx->connect(cableserver_client_ctx->handle, lattice_host_name, NULL, NULL)!=0){
+		LOG_ERROR("Error:: connect to cableserver failed\n");
+		return ERROR_FAIL;
+	}
+
+	//detect cable
+	status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_QueryCablewDescription);
+	if(status<0){
+		status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_QueryCable);
+		if(status<0){
+			fprintf(stderr, "Error: Query cable failed\n");
+			return ERROR_FAIL;
+		}
+	}
+	cableserver_client_ctx->read(cableserver_client_ctx->handle, dev_buff, &dev_num);
+
+	fprintf(stderr, "Cable List : \n");
+	for (int i=0; i<dev_num; i++){
+		fprintf(stderr, "    ");
+		for (int j=0; j<100; j++)
+			fprintf(stderr, "%c", dev_buff[i][j]);
+		fprintf(stderr, "\n");
+	}
+	dev_num=0;
+	
+	//set cable
+	status=cableserver_client_ctx->send(cableserver_client_ctx->handle, D_SetCablePort, lattice_cable, lattice_port, 0);
+	if(status <0){
+		LOG_ERROR("Set cable port failed(%d), Please select correct port number (FTUSB-?) from \'Cable List\'.",status);
+		//cableserver_client_ctx->client_disconnect(p_cableserver_client_ctx->p_client_handle);
+		//LOG_ERROR("set cable port failed(%d), please connect it again11\n",status);
+		return ERROR_FAIL;
+	}
+
+	if(cableserver_client_ctx->send(cableserver_client_ctx->handle, D_LockCable)!=0){
+		LOG_ERROR("Lock cable failed\n");
+		return ERROR_FAIL;
+	}
+
+	//scan device
+	memset(dev_buff, '\0', 10*256);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_ScanDeviceChain);
+	cableserver_client_ctx->read(cableserver_client_ctx->handle, dev_buff, &dev_num);
+	
+	fprintf(stderr, "Device List: \n");
+	for (int i=0; i<dev_num; i++){
+		fprintf(stderr, "    ");
+		for (int j=0; j<100; j++)
+			fprintf(stderr, "%c", dev_buff[i][j]);
+		fprintf(stderr, "\n");
+	}
+	daisy_chain_ctx->num=dev_num;
+	
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagTEST_LOGIC_RESET);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	
+	cmd_data=calloc(daisy_chain_ctx->num, sizeof(unsigned char));
+	unsigned char id_code=0xe0;
+	unsigned char id_list[4*3];
+	
+	memset(id_list, '\0', 4*3);
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=id_code;
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, cmd_data);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 32+daisy_chain_ctx->num-1, TDO_YES, id_list);
+	cableserver_client_ctx->get_tdo_u(cableserver_client_ctx->handle, id_list, 32+daisy_chain_ctx->num-1);
+
+	if (id_list[1]==0xff &&
+		id_list[2]==0xff&&
+		id_list[3]==0xff){
+		fprintf(stderr, "Error: Please select correct port number (FTUSB-?) from \'Cable List\'.");
+		return ERROR_FAIL;
+	}
+
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8, TDO_NO, er1_data);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_DR, 21, TDO_NO, select_channel);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8, TDO_NO, enable_nop);
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_JumpState, jtagRUN_TEST_IDLE);
+
+	memset(cmd_data, 0xFF, (daisy_chain_ctx->num)*sizeof(unsigned char));
+	cmd_data[daisy_chain_ctx->target]=er2_data[0];
+	cableserver_client_ctx->send(cableserver_client_ctx->handle, D_Shift, SHI_IR, 8*(daisy_chain_ctx->num), TDO_NO, cmd_data);
+	free(cmd_data);
+	return ERROR_OK;
+}
+
+void cableserver_proc_exit(void){ //WIN, kill process cableserver.exe
+	HANDLE process_list = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+
+	PROCESSENTRY32 process_entry;
+	process_entry.dwSize = sizeof(PROCESSENTRY32);
+
+	//get the first process
+	if (false == Process32First(process_list, &process_entry))
+		return;
+
+	while (Process32Next(process_list, &process_entry)){
+		if(strcmp(process_entry.szExeFile, "cableserver.exe") == 0){
+			uint32_t process_id = process_entry.th32ProcessID;
+			HANDLE process_handle = OpenProcess(PROCESS_TERMINATE, false, process_id);
+			TerminateProcess(process_handle, 0);
+			CloseHandle(process_handle);
+			break;
+		}
+	}
+}
+
+static int lscc_cableserver_execute_queue(void)
+{
+	for (struct jtag_command *cmd = jtag_command_queue; cmd; cmd = cmd->next) {
+		/* fill the write buffer with the desired command */
+		cableserver_execute_command(cmd);
+	}
+
+	int retval = cableserver_buffer_flush();
+	if (retval != ERROR_OK)
+		LOG_ERROR("error while flushing MPSSE queue: %d", retval);
+	return retval;
+}
+
+static int lscc_cableserver_speed(int speed){
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_khz(int khz, int *jtag_speed){
+	*jtag_speed = khz;
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_speed_div(int speed, int *khz){
+	*khz = speed;
+	return ERROR_OK;
+}
+
+static int lscc_cableserver_init(void){
+	cableserver_proc_exit();
+	cableserver_client_ctx= cableserver_open();
+	if (!cableserver_client_ctx)
+		return ERROR_JTAG_INIT_FAILED;
+	return cableserver_config();//isp tracy config  
+}
+
+static int lscc_cableserver_quit(void){
+	DEBUG_JTAG_IO("cableserver_quit");
+	cableserver_close("USB2", "FTUSB-0");
+	free(cableserver_client_ctx);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_server_info_command){
+	DEBUG_JTAG_IO("lattice cable server info version: RC1");
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(lattice_cable_port_select_command){
+	DEBUG_JTAG_IO("lattice_cable_port_select_command");
+	lattice_port = strdup(CMD_ARGV[0]);
+	return ERROR_OK;
+}
+
+static const struct command_registration lscc_cableserver_cmd_handlers[] = {
+	{
+		.name = "lscc_cableserver_info",
+		.handler = lattice_cable_server_info_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the lattice cable description of the lattice driver",
+		.usage = "description-string",
+	},
+	
+	{
+		.name = "lattice_port_select",
+		.handler = lattice_cable_port_select_command,
+		.mode = COMMAND_CONFIG,
+		.help = "cable port select",
+		.usage = "vid pid vid_uninit pid_uninit",
+	},
+	
+	COMMAND_REGISTRATION_DONE
+};
+
+static const char * const lscc_transports[] = {"swd", "jtag", NULL};
+
+//************************lattice cableserver interface*************************************
+//
+//vexRiscV component==>lattice driver(JTAG logic, cableserver client logic, ispTracy logic, bridge logic)
+//==>cableserver==>ispTracy==>bridge==>JTAG==>debug module==>vexRiscV core
+//
+//*********************************end************************************************
+struct jtag_interface lscc_cableserver_interface = {
+	.name = "lattice-usb-cableserver",
+	.commands = lscc_cableserver_cmd_handlers,  
+	.transports = jtag_only,
+	.execute_queue = lscc_cableserver_execute_queue,
+	.speed = lscc_cableserver_speed,
+	.speed_div = lscc_cableserver_speed_div,
+	.khz = lscc_cableserver_khz,
+	.init = lscc_cableserver_init,
+	.quit = lscc_cableserver_quit,
+};
+
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index a26c868..e8e0a41 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -136,6 +136,9 @@ extern struct jtag_interface imx_gpio_interface;
 #if BUILD_XDS110 == 1
 extern struct jtag_interface xds110_interface;
 #endif
+#if BUILD_LSCC_USB_CABLESERVER ==1
+extern struct jtag_interface lscc_cableserver_interface;
+#endif
 #endif /* standard drivers */
 
 /**
@@ -242,6 +245,11 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_XDS110 == 1
 		&xds110_interface,
 #endif
+
+#if BUILD_LSCC_USB_CABLESERVER ==1
+		&lscc_cableserver_interface,
+#endif
+
 #endif /* standard drivers */
 		NULL,
 	};
diff --git a/tcl/interface/lattice-usb-cableserver.cfg b/tcl/interface/lattice-usb-cableserver.cfg
new file mode 100644
index 0000000..aff71eb
--- /dev/null
+++ b/tcl/interface/lattice-usb-cableserver.cfg
@@ -0,0 +1,12 @@
+#Lattice Driver interface
+
+interface lattice-usb-cableserver
+
+# no TRST/SRST signal is available on the Lattice adapter
+reset_config none
+
+transport select jtag
+
+# Start with low (safe) speed.
+# The user can increase it later as needed.
+adapter_khz 4000
\ No newline at end of file
diff --git a/tcl/target/riscv-small.cfg b/tcl/target/riscv-small.cfg
new file mode 100644
index 0000000..3364717
--- /dev/null
+++ b/tcl/target/riscv-small.cfg
@@ -0,0 +1,32 @@
+interface dummy
+
+set  _ENDIAN little
+set _TAP_TYPE 1234
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # set useful default
+   set _CPUTAPID 0x10001fff 
+}
+
+adapter_khz 4000
+adapter_nsrst_delay 260
+jtag_ntrst_delay 250
+
+set _CHIPNAME fpga_spinal
+jtag newtap $_CHIPNAME bridge -expected-id $_CPUTAPID -irlen 4 -ircapture 0x1 -irmask 0xF 
+
+target create $_CHIPNAME.cpu0 vexriscv -endian $_ENDIAN -chain-position $_CHIPNAME.bridge -coreid 0 -dbgbase 0xF00F0000
+#target create $_CHIPNAME.cpu0 vexriscv -endian $_ENDIAN -chain-position $_CHIPNAME.bridge -coreid 0 -dbgbase 0x00000000
+vexriscv readWaitCycles 12
+vexriscv cpuConfigFile $RISCV_SMALL_YAML
+
+
+poll_period 50
+
+
+
+init
+#echo "Halting processor"
+#soft_reset_halt
-- 
1.9.1

